/* tslint:disable */
/* eslint-disable */
/**
 * Euler Stream Sign API
 * Sign Server API Documentation
 *
 * The version of the OpenAPI document: dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'minute': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'webhook_secret': string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'max_alerts': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'max_websockets': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'expires_at': string | null;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'purchased_captcha_credits': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface AccountConfig
 */
export interface AccountConfig {
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'minute': number;
    /**
     * 
     * @type {string}
     * @memberof AccountConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountConfig
     */
    'webhook_secret': string;
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'max_alerts': number;
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'max_websockets': number;
    /**
     * 
     * @type {string}
     * @memberof AccountConfig
     */
    'expires_at': string | null;
}
/**
 * 
 * @export
 * @enum {number}
 */

export const AccountScopes = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_8: 8,
    NUMBER_6: 6,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15
} as const;

export type AccountScopes = typeof AccountScopes[keyof typeof AccountScopes];


/**
 * 
 * @export
 * @interface AccountWithPermissionsSafe
 */
export interface AccountWithPermissionsSafe {
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'minute': number;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'webhook_secret': string;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'max_alerts': number;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'max_websockets': number;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'expires_at': string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'purchased_captcha_credits': number;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'id': number;
    /**
     * 
     * @type {Array<AccountScopes>}
     * @memberof AccountWithPermissionsSafe
     */
    'scopes': Array<AccountScopes>;
}
/**
 * 
 * @export
 * @interface AccountsTableRequestLimits
 */
export interface AccountsTableRequestLimits {
    /**
     * 
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'minute': number;
}
/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    'read_only': boolean;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_nickname': string | null;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_avatar_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_username': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface AlertConfig
 */
export interface AlertConfig {
    /**
     * 
     * @type {number}
     * @memberof AlertConfig
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof AlertConfig
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof AlertConfig
     */
    'read_only': boolean;
}
/**
 * 
 * @export
 * @interface AlertTarget
 */
export interface AlertTarget {
    /**
     * 
     * @type {string}
     * @memberof AlertTarget
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof AlertTarget
     */
    'metadata': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof AlertTarget
     */
    'alert_id': number;
    /**
     * 
     * @type {number}
     * @memberof AlertTarget
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {AlertTargetStatus}
     * @memberof AlertTarget
     */
    'last_status': AlertTargetStatus;
    /**
     * 
     * @type {AlertTargetFormat}
     * @memberof AlertTarget
     */
    'format': AlertTargetFormat;
    /**
     * 
     * @type {number}
     * @memberof AlertTarget
     */
    'account_id': number;
    /**
     * 
     * @type {string}
     * @memberof AlertTarget
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof AlertTarget
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof AlertTarget
     */
    'id': number;
}


/**
 * 
 * @export
 * @interface AlertTargetConfig
 */
export interface AlertTargetConfig {
    /**
     * 
     * @type {string}
     * @memberof AlertTargetConfig
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof AlertTargetConfig
     */
    'metadata': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof AlertTargetConfig
     */
    'alert_id': number;
    /**
     * 
     * @type {number}
     * @memberof AlertTargetConfig
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {AlertTargetStatus}
     * @memberof AlertTargetConfig
     */
    'last_status': AlertTargetStatus;
    /**
     * 
     * @type {AlertTargetFormat}
     * @memberof AlertTargetConfig
     */
    'format': AlertTargetFormat;
}


/**
 * 
 * @export
 * @enum {number}
 */

export const AlertTargetFormat = {
    NUMBER_1: 1
} as const;

export type AlertTargetFormat = typeof AlertTargetFormat[keyof typeof AlertTargetFormat];


/**
 * 
 * @export
 * @enum {number}
 */

export const AlertTargetStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_4: 4
} as const;

export type AlertTargetStatus = typeof AlertTargetStatus[keyof typeof AlertTargetStatus];


/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'account_id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ApiKeyConfig
 */
export interface ApiKeyConfig {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyConfig
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyConfig
     */
    'account_id': number;
}
/**
 * 
 * @export
 * @interface CaptchaCreditsResponse
 */
export interface CaptchaCreditsResponse {
    /**
     * 
     * @type {number}
     * @memberof CaptchaCreditsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CaptchaCreditsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof CaptchaCreditsResponse
     */
    'credits': number;
}
/**
 * Configuration for the alert
 * @export
 * @interface CreateAlertRequest
 */
export interface CreateAlertRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertRequest
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface CreateAlertResponse
 */
export interface CreateAlertResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateAlertResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Alert}
     * @memberof CreateAlertResponse
     */
    'alert'?: Alert;
}
/**
 * 
 * @export
 * @interface CreateAlertTargetPayload
 */
export interface CreateAlertTargetPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertTargetPayload
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof CreateAlertTargetPayload
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreateAlertTargetResponse
 */
export interface CreateAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertTargetResponse
     */
    'message'?: string;
    /**
     * 
     * @type {AlertTarget}
     * @memberof CreateAlertTargetResponse
     */
    'target'?: AlertTarget;
}
/**
 * 
 * @export
 * @interface CreateJWTResponse
 */
export interface CreateJWTResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateJWTResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CreateJWTResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateJWTResponse
     */
    'token'?: string;
    /**
     * 
     * @type {JWTConfig}
     * @memberof CreateJWTResponse
     */
    'config'?: JWTConfig;
}
/**
 * 
 * @export
 * @interface CreateKeyPayload
 */
export interface CreateKeyPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateKeyPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateKeyResponse
 */
export interface CreateKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CreateKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ApiKey}
     * @memberof CreateKeyResponse
     */
    'key'?: ApiKey;
}
/**
 * 
 * @export
 * @interface DeleteAlertResponse
 */
export interface DeleteAlertResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteAlertResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteAlertResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteAlertTargetResponse
 */
export interface DeleteAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteAlertTargetResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteKeyResponse
 */
export interface DeleteKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteKeyResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ExchangeTokenRequest
 */
export interface ExchangeTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ExchangeTokenRequest
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeTokenRequest
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeTokenRequest
     */
    'grant_type': ExchangeTokenRequestGrantTypeEnum;
    /**
     * Required for authorization_code grant
     * @type {string}
     * @memberof ExchangeTokenRequest
     */
    'code'?: string;
    /**
     * Required for authorization_code grant
     * @type {string}
     * @memberof ExchangeTokenRequest
     */
    'redirect_uri'?: string;
    /**
     * Required for refresh_token grant
     * @type {string}
     * @memberof ExchangeTokenRequest
     */
    'refresh_token'?: string;
}

export const ExchangeTokenRequestGrantTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token'
} as const;

export type ExchangeTokenRequestGrantTypeEnum = typeof ExchangeTokenRequestGrantTypeEnum[keyof typeof ExchangeTokenRequestGrantTypeEnum];

/**
 * 
 * @export
 * @interface GetRateLimits
 */
export interface GetRateLimits {
    /**
     * 
     * @type {number}
     * @memberof GetRateLimits
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof GetRateLimits
     */
    'message'?: string;
    /**
     * 
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'day'?: RateLimitInfo;
    /**
     * 
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'hour'?: RateLimitInfo;
    /**
     * 
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'minute'?: RateLimitInfo;
    /**
     * 
     * @type {LoadShedInfo}
     * @memberof GetRateLimits
     */
    'load_shedding': LoadShedInfo;
}
/**
 * 
 * @export
 * @interface GetSignWebcastUrlResponse
 */
export interface GetSignWebcastUrlResponse {
    /**
     * 
     * @type {number}
     * @memberof GetSignWebcastUrlResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'signedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'msToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'browserVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'browserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    '_signature'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'X-Bogus'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'User-Agent'?: string;
}
/**
 * 
 * @export
 * @interface HashtagListAPIResponse
 */
export interface HashtagListAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof HashtagListAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof HashtagListAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastHashtagListRouteOutput}
     * @memberof HashtagListAPIResponse
     */
    'response'?: WebcastHashtagListRouteOutput;
}
/**
 * 
 * @export
 * @interface HostsResponse
 */
export interface HostsResponse {
    /**
     * 
     * @type {number}
     * @memberof HostsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof HostsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PeerPresence>}
     * @memberof HostsResponse
     */
    'hosts'?: Array<PeerPresence>;
}
/**
 * 
 * @export
 * @interface IconCaptchaResponse
 */
export interface IconCaptchaResponse {
    /**
     * 
     * @type {IconsResult}
     * @memberof IconCaptchaResponse
     */
    'response': IconsResult | null;
    /**
     * 
     * @type {boolean}
     * @memberof IconCaptchaResponse
     */
    'cached': boolean;
    /**
     * 
     * @type {number}
     * @memberof IconCaptchaResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IconCaptchaResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IconsResult
 */
export interface IconsResult {
    /**
     * 
     * @type {number}
     * @memberof IconsResult
     */
    'time_ms': number;
    /**
     * 
     * @type {Array<Point>}
     * @memberof IconsResult
     */
    'points': Array<Point>;
    /**
     * 
     * @type {string}
     * @memberof IconsResult
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface JSONResponse
 */
export interface JSONResponse {
    /**
     * 
     * @type {number}
     * @memberof JSONResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof JSONResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface JWTConfig
 */
export interface JWTConfig {
    /**
     * 
     * @type {string}
     * @memberof JWTConfig
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof JWTConfig
     */
    'expiresAt': number;
    /**
     * 
     * @type {number}
     * @memberof JWTConfig
     */
    'ttl': number;
    /**
     * 
     * @type {number}
     * @memberof JWTConfig
     */
    'accountId': number;
    /**
     * 
     * @type {number}
     * @memberof JWTConfig
     */
    'apiKeyId': number;
    /**
     * 
     * @type {AccountsTableRequestLimits}
     * @memberof JWTConfig
     */
    'limits': AccountsTableRequestLimits;
    /**
     * 
     * @type {JWTConfigWebSocketData}
     * @memberof JWTConfig
     */
    'webSocketData': JWTConfigWebSocketData;
    /**
     * 
     * @type {string}
     * @memberof JWTConfig
     */
    'name': string | null;
}
/**
 * 
 * @export
 * @interface JWTConfigWebSocketData
 */
export interface JWTConfigWebSocketData {
    /**
     * 
     * @type {string}
     * @memberof JWTConfigWebSocketData
     */
    'encryptedTtTargetIdc'?: string;
    /**
     * 
     * @type {string}
     * @memberof JWTConfigWebSocketData
     */
    'encryptedSessionId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof JWTConfigWebSocketData
     */
    'allowedCreators': Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof JWTConfigWebSocketData
     */
    'maxWebSockets': number;
}
/**
 * 
 * @export
 * @interface JWTCreateConfig
 */
export interface JWTCreateConfig {
    /**
     * 
     * @type {AccountsTableRequestLimits}
     * @memberof JWTCreateConfig
     */
    'limits'?: AccountsTableRequestLimits | null;
    /**
     * 
     * @type {JWTCreateConfigWebSocketData}
     * @memberof JWTCreateConfig
     */
    'websockets'?: JWTCreateConfigWebSocketData | null;
    /**
     * 
     * @type {number}
     * @memberof JWTCreateConfig
     */
    'expireAfter': number;
    /**
     * 
     * @type {string}
     * @memberof JWTCreateConfig
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface JWTCreateConfigWebSocketData
 */
export interface JWTCreateConfigWebSocketData {
    /**
     * 
     * @type {string}
     * @memberof JWTCreateConfigWebSocketData
     */
    'ttTargetIdc'?: string;
    /**
     * 
     * @type {string}
     * @memberof JWTCreateConfigWebSocketData
     */
    'sessionId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof JWTCreateConfigWebSocketData
     */
    'allowedCreators': Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof JWTCreateConfigWebSocketData
     */
    'maxWebSockets': number;
}
/**
 * 
 * @export
 * @interface ListAlertTargetsResponse
 */
export interface ListAlertTargetsResponse {
    /**
     * 
     * @type {number}
     * @memberof ListAlertTargetsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ListAlertTargetsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<AlertTarget>}
     * @memberof ListAlertTargetsResponse
     */
    'targets'?: Array<AlertTarget>;
}
/**
 * 
 * @export
 * @interface ListAlertsResponse
 */
export interface ListAlertsResponse {
    /**
     * 
     * @type {number}
     * @memberof ListAlertsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ListAlertsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof ListAlertsResponse
     */
    'alerts'?: Array<Alert>;
    /**
     * 
     * @type {boolean}
     * @memberof ListAlertsResponse
     */
    'hasMore': boolean;
}
/**
 * 
 * @export
 * @interface ListKeysResponse
 */
export interface ListKeysResponse {
    /**
     * 
     * @type {number}
     * @memberof ListKeysResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ListKeysResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ListKeysResponse
     */
    'keys'?: Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface LiveAnalyticsVideoDetailAPIResponse
 */
export interface LiveAnalyticsVideoDetailAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof LiveAnalyticsVideoDetailAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof LiveAnalyticsVideoDetailAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailRouteOutput}
     * @memberof LiveAnalyticsVideoDetailAPIResponse
     */
    'response'?: WebcastLiveAnalyticsVideoDetailRouteOutput;
}
/**
 * 
 * @export
 * @interface LiveAnalyticsVideoListAPIResponse
 */
export interface LiveAnalyticsVideoListAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof LiveAnalyticsVideoListAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof LiveAnalyticsVideoListAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoListRouteOutput}
     * @memberof LiveAnalyticsVideoListAPIResponse
     */
    'response'?: WebcastLiveAnalyticsVideoListRouteOutput;
}
/**
 * 
 * @export
 * @interface LoadShedInfo
 */
export interface LoadShedInfo {
    /**
     * 
     * @type {number}
     * @memberof LoadShedInfo
     */
    'at': number;
    /**
     * 
     * @type {number}
     * @memberof LoadShedInfo
     */
    'chance': number;
}
/**
 * Mute duration in seconds
 * @export
 * @enum {number}
 */

export const MuteDuration = {
    NUMBER_MINUS_1: -1,
    NUMBER_5: 5,
    NUMBER_30: 30,
    NUMBER_60: 60,
    NUMBER_300: 300
} as const;

export type MuteDuration = typeof MuteDuration[keyof typeof MuteDuration];


/**
 * 
 * @export
 * @interface OAuthRevokeResponse
 */
export interface OAuthRevokeResponse {
    /**
     * 
     * @type {number}
     * @memberof OAuthRevokeResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof OAuthRevokeResponse
     */
    'message'?: string;
    /**
     * 
     * @type {TokenErrorResponse}
     * @memberof OAuthRevokeResponse
     */
    'error'?: TokenErrorResponse;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthScope = {
    WebcastFetch: 'webcast:fetch',
    WebcastRankings: 'webcast:rankings',
    WebcastBulkLiveCheck: 'webcast:bulk_live_check',
    WebcastUserEarnings: 'webcast:user_earnings',
    WebcastSignUrl: 'webcast:sign_url',
    WebcastChat: 'webcast:chat',
    WebcastMute: 'webcast:mute',
    WebcastBan: 'webcast:ban',
    WebcastComments: 'webcast:comments',
    WebcastModerators: 'webcast:moderators',
    WebcastLiveAnalytics: 'webcast:live_analytics',
    UserConsents: 'user:consents'
} as const;

export type OAuthScope = typeof OAuthScope[keyof typeof OAuthScope];


/**
 * 
 * @export
 * @interface OAuthTokenResponse
 */
export interface OAuthTokenResponse {
    /**
     * 
     * @type {number}
     * @memberof OAuthTokenResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'message'?: string;
    /**
     * 
     * @type {TokenResponse}
     * @memberof OAuthTokenResponse
     */
    'data'?: TokenResponse;
    /**
     * 
     * @type {TokenErrorResponse}
     * @memberof OAuthTokenResponse
     */
    'error'?: TokenErrorResponse;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OxyLabsProxyRegion = {
    Us: 'US',
    Gb: 'GB',
    De: 'DE',
    Ro: 'RO',
    Es: 'ES',
    Be: 'BE',
    Fr: 'FR',
    Ca: 'CA',
    Jp: 'JP',
    Br: 'BR',
    Mx: 'MX',
    Co: 'CO',
    Ar: 'AR',
    Cl: 'CL',
    Au: 'AU',
    Kr: 'KR',
    Pe: 'PE',
    Pl: 'PL',
    Sg: 'SG',
    It: 'IT'
} as const;

export type OxyLabsProxyRegion = typeof OxyLabsProxyRegion[keyof typeof OxyLabsProxyRegion];


/**
 * Make all properties in T optional
 * @export
 * @interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
 */
export interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber {
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'sec_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'numeric_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'signature'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'following'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'followers'?: number;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
 */
export interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray {
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'signedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'userAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'browserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'browserVersion'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'tokens'?: { [key: string]: string; };
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'requestHeaders'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'cookies'?: Array<{ [key: string]: string; }>;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
 */
export interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString {
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'status'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'is_live'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'cover_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'start_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'current_viewers'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'total_viewers'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'hls_pull_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'flv_pull_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'hls_pull_url_ld'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'flv_pull_url_ld'?: string;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialWebcastRegionRankingsOutputRank
 */
export interface PartialWebcastRegionRankingsOutputRank {
    /**
     * 
     * @type {number}
     * @memberof PartialWebcastRegionRankingsOutputRank
     */
    'rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialWebcastRegionRankingsOutputRank
     */
    'diamonds'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartialWebcastRegionRankingsOutputRank
     */
    'diamonds_description'?: string;
    /**
     * 
     * @type {PartialWebcastRegionRankingsOutputRankUser}
     * @memberof PartialWebcastRegionRankingsOutputRank
     */
    'user'?: PartialWebcastRegionRankingsOutputRankUser;
}
/**
 * 
 * @export
 * @interface PartialWebcastRegionRankingsOutputRankUser
 */
export interface PartialWebcastRegionRankingsOutputRankUser {
    /**
     * 
     * @type {string}
     * @memberof PartialWebcastRegionRankingsOutputRankUser
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof PartialWebcastRegionRankingsOutputRankUser
     */
    'numeric_id': string;
    /**
     * 
     * @type {string}
     * @memberof PartialWebcastRegionRankingsOutputRankUser
     */
    'unique_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PartialWebcastRegionRankingsOutputRankUser
     */
    'avatar_thumb': Array<string>;
}
/**
 * 
 * @export
 * @interface PeerPresence
 */
export interface PeerPresence {
    /**
     * 
     * @type {number}
     * @memberof PeerPresence
     */
    'lastSeen': number;
    /**
     * 
     * @type {PeerRole}
     * @memberof PeerPresence
     */
    'role': PeerRole;
    /**
     * 
     * @type {string}
     * @memberof PeerPresence
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PeerPresence
     */
    'type': PeerPresenceTypeEnum;
}

export const PeerPresenceTypeEnum = {
    Api: 'api',
    Agent: 'agent'
} as const;

export type PeerPresenceTypeEnum = typeof PeerPresenceTypeEnum[keyof typeof PeerPresenceTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const PeerRole = {
    Public: 'public',
    Enterprise: 'enterprise',
    Staging: 'staging'
} as const;

export type PeerRole = typeof PeerRole[keyof typeof PeerRole];


/**
 * Captcha Server No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  The version of the OpenAPI document: 0.1   NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech). https://openapi-generator.tech Do not edit the class manually.
 * @export
 * @interface Point
 */
export interface Point {
    /**
     * 
     * @type {number}
     * @memberof Point
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Point
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface PuzzleCaptchaResponse
 */
export interface PuzzleCaptchaResponse {
    /**
     * 
     * @type {PuzzleResult}
     * @memberof PuzzleCaptchaResponse
     */
    'response': PuzzleResult | null;
    /**
     * 
     * @type {boolean}
     * @memberof PuzzleCaptchaResponse
     */
    'cached': boolean;
    /**
     * 
     * @type {number}
     * @memberof PuzzleCaptchaResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PuzzleCaptchaResponse
     */
    'message'?: string;
}
/**
 * Captcha Server No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  The version of the OpenAPI document: 0.1   NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech). https://openapi-generator.tech Do not edit the class manually.
 * @export
 * @interface PuzzleResult
 */
export interface PuzzleResult {
    /**
     * 
     * @type {number}
     * @memberof PuzzleResult
     */
    'time_ms': number;
    /**
     * 
     * @type {number}
     * @memberof PuzzleResult
     */
    'x': number;
}
/**
 * 
 * @export
 * @interface RateLimitInfo
 */
export interface RateLimitInfo {
    /**
     * 
     * @type {number}
     * @memberof RateLimitInfo
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof RateLimitInfo
     */
    'remaining': number;
    /**
     * 
     * @type {string}
     * @memberof RateLimitInfo
     */
    'reset_at': string | null;
}
/**
 * 
 * @export
 * @interface RecordStringBooleanOrNumberValue
 */
export interface RecordStringBooleanOrNumberValue {
}
/**
 * 
 * @export
 * @interface RecordStringIsLiveBooleanRoomIdStringOrNullValue
 */
export interface RecordStringIsLiveBooleanRoomIdStringOrNullValue {
    /**
     * 
     * @type {string}
     * @memberof RecordStringIsLiveBooleanRoomIdStringOrNullValue
     */
    'room_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof RecordStringIsLiveBooleanRoomIdStringOrNullValue
     */
    'is_live': boolean;
}
/**
 * 
 * @export
 * @interface RetrieveAccountResponse
 */
export interface RetrieveAccountResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveAccountResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountResponse
     */
    'message'?: string;
    /**
     * 
     * @type {AccountWithPermissionsSafe}
     * @memberof RetrieveAccountResponse
     */
    'account'?: AccountWithPermissionsSafe;
}
/**
 * 
 * @export
 * @interface RetrieveAgentHostsResponse
 */
export interface RetrieveAgentHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveAgentHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAgentHostsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PeerPresence>}
     * @memberof RetrieveAgentHostsResponse
     */
    'agents': Array<PeerPresence>;
}
/**
 * 
 * @export
 * @interface RetrieveAlertResponse
 */
export interface RetrieveAlertResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveAlertResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Alert}
     * @memberof RetrieveAlertResponse
     */
    'alert'?: Alert;
    /**
     * 
     * @type {RetrieveAlertResponseCreator}
     * @memberof RetrieveAlertResponse
     */
    'creator'?: RetrieveAlertResponseCreator;
}
/**
 * 
 * @export
 * @interface RetrieveAlertResponseCreator
 */
export interface RetrieveAlertResponseCreator {
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'last_nickname': string | null;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'last_avatar_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'room_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'state_label': string;
    /**
     * 
     * @type {number}
     * @memberof RetrieveAlertResponseCreator
     */
    'state': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface RetrieveBulkLiveCheckPayload
 */
export interface RetrieveBulkLiveCheckPayload {
    /**
     * 
     * @type {Array<string>}
     * @memberof RetrieveBulkLiveCheckPayload
     */
    'user_numeric_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface RetrieveBulkLiveCheckPayloadV1
 */
export interface RetrieveBulkLiveCheckPayloadV1 {
    /**
     * 
     * @type {Array<string>}
     * @memberof RetrieveBulkLiveCheckPayloadV1
     */
    'user_numeric_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RetrieveBulkLiveCheckPayloadV1
     * @deprecated
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveBulkLiveCheckPayloadV1
     * @deprecated
     */
    'tt_target_idc'?: string;
}
/**
 * The body of the request containing user numeric IDs.
 * @export
 * @interface RetrieveBulkLiveCheckRequest
 */
export interface RetrieveBulkLiveCheckRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RetrieveBulkLiveCheckRequest
     */
    'user_numeric_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RetrieveBulkLiveCheckRequest
     * @deprecated
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveBulkLiveCheckRequest
     * @deprecated
     */
    'tt_target_idc'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveBulkLiveCheckResponse
 */
export interface RetrieveBulkLiveCheckResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveBulkLiveCheckResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveBulkLiveCheckResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastIsLiveOutput}
     * @memberof RetrieveBulkLiveCheckResponse
     */
    'response'?: WebcastIsLiveOutput;
}
/**
 * 
 * @export
 * @interface RetrieveKeyResponse
 */
export interface RetrieveKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ApiKey}
     * @memberof RetrieveKeyResponse
     */
    'key'?: ApiKey;
}
/**
 * 
 * @export
 * @interface RevokeRequestBody
 */
export interface RevokeRequestBody {
    /**
     * 
     * @type {string}
     * @memberof RevokeRequestBody
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof RevokeRequestBody
     */
    'token_type_hint'?: RevokeRequestBodyTokenTypeHintEnum;
    /**
     * 
     * @type {string}
     * @memberof RevokeRequestBody
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof RevokeRequestBody
     */
    'client_secret': string;
}

export const RevokeRequestBodyTokenTypeHintEnum = {
    AccessToken: 'access_token',
    RefreshToken: 'refresh_token'
} as const;

export type RevokeRequestBodyTokenTypeHintEnum = typeof RevokeRequestBodyTokenTypeHintEnum[keyof typeof RevokeRequestBodyTokenTypeHintEnum];

/**
 * 
 * @export
 * @interface RoomAdminUpdateAPIResponse
 */
export interface RoomAdminUpdateAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomAdminUpdateAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomAdminUpdateAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomAdminUpdateRouteOutput}
     * @memberof RoomAdminUpdateAPIResponse
     */
    'response'?: WebcastRoomAdminUpdateRouteOutput;
}
/**
 * 
 * @export
 * @interface RoomCommentsToggleAPIResponse
 */
export interface RoomCommentsToggleAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomCommentsToggleAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomCommentsToggleAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomCommentsToggleRouteOutput}
     * @memberof RoomCommentsToggleAPIResponse
     */
    'response'?: WebcastRoomCommentsToggleRouteOutput;
}
/**
 * 
 * @export
 * @interface RoomKickUserAPIResponse
 */
export interface RoomKickUserAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomKickUserAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomKickUserAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomKickUserRouteOutput}
     * @memberof RoomKickUserAPIResponse
     */
    'response'?: WebcastRoomKickUserRouteOutput;
}
/**
 * 
 * @export
 * @interface RoomKickedUsersAPIResponse
 */
export interface RoomKickedUsersAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomKickedUsersAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomKickedUsersAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomKickedUsersRouteOutput}
     * @memberof RoomKickedUsersAPIResponse
     */
    'response'?: WebcastRoomKickedUsersRouteOutput;
}
/**
 * 
 * @export
 * @interface RoomModeratorsAPIResponse
 */
export interface RoomModeratorsAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomModeratorsAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomModeratorsAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomAdminListRouteOutput}
     * @memberof RoomModeratorsAPIResponse
     */
    'response'?: WebcastRoomAdminListRouteOutput;
}
/**
 * 
 * @export
 * @interface RoomMuteUserAPIResponse
 */
export interface RoomMuteUserAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomMuteUserAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomMuteUserAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomMuteUserRouteOutput}
     * @memberof RoomMuteUserAPIResponse
     */
    'response'?: WebcastRoomMuteUserRouteOutput;
}
/**
 * 
 * @export
 * @interface RoomMutedUsersAPIResponse
 */
export interface RoomMutedUsersAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomMutedUsersAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomMutedUsersAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomMutedUsersRouteOutput}
     * @memberof RoomMutedUsersAPIResponse
     */
    'response'?: WebcastRoomMutedUsersRouteOutput;
}
/**
 * 
 * @export
 * @interface RoomUnkickUserAPIResponse
 */
export interface RoomUnkickUserAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomUnkickUserAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomUnkickUserAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomUnkickUserRouteOutput}
     * @memberof RoomUnkickUserAPIResponse
     */
    'response'?: WebcastRoomUnkickUserRouteOutput;
}
/**
 * 
 * @export
 * @interface RoomUnmuteUserAPIResponse
 */
export interface RoomUnmuteUserAPIResponse {
    /**
     * 
     * @type {number}
     * @memberof RoomUnmuteUserAPIResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RoomUnmuteUserAPIResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRoomUnmuteUserRouteOutput}
     * @memberof RoomUnmuteUserAPIResponse
     */
    'response'?: WebcastRoomUnmuteUserRouteOutput;
}
/**
 * The payload configuration for sending a chat
 * @export
 * @interface SendRoomChatRequest
 */
export interface SendRoomChatRequest {
    /**
     * The chat message content to send
     * @type {string}
     * @memberof SendRoomChatRequest
     */
    'content': string;
    /**
     * The room ID to send the chat to (either this or targetUniqueId is required)
     * @type {string}
     * @memberof SendRoomChatRequest
     */
    'targetRoomId'?: string;
    /**
     * The username of the room to send the chat to (either this or targetRoomId is required)
     * @type {string}
     * @memberof SendRoomChatRequest
     */
    'targetUniqueId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SendRoomChatRequest
     * @deprecated
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof SendRoomChatRequest
     * @deprecated
     */
    'ttTargetIdc'?: string;
}
/**
 * 
 * @export
 * @interface ShapesCaptchaResponse
 */
export interface ShapesCaptchaResponse {
    /**
     * 
     * @type {ShapesResult}
     * @memberof ShapesCaptchaResponse
     */
    'response': ShapesResult | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShapesCaptchaResponse
     */
    'cached': boolean;
    /**
     * 
     * @type {number}
     * @memberof ShapesCaptchaResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ShapesCaptchaResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ShapesResult
 */
export interface ShapesResult {
    /**
     * 
     * @type {number}
     * @memberof ShapesResult
     */
    'time_ms': number;
    /**
     * 
     * @type {Point}
     * @memberof ShapesResult
     */
    'point_1': Point;
    /**
     * 
     * @type {Point}
     * @memberof ShapesResult
     */
    'point_2': Point;
}
/**
 * 
 * @export
 * @interface SignTikTokUrlBody
 */
export interface SignTikTokUrlBody {
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'userAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'method'?: SignTikTokUrlBodyMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'ttTargetIdc'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'ttwid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'payload'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'type'?: SignTikTokUrlBodyTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SignTikTokUrlBody
     */
    'includeBrowserParams'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SignTikTokUrlBody
     */
    'includeVerifyFp'?: boolean;
}

export const SignTikTokUrlBodyMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Options: 'OPTIONS',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD'
} as const;

export type SignTikTokUrlBodyMethodEnum = typeof SignTikTokUrlBodyMethodEnum[keyof typeof SignTikTokUrlBodyMethodEnum];
export const SignTikTokUrlBodyTypeEnum = {
    Fetch: 'fetch',
    Xhr: 'xhr'
} as const;

export type SignTikTokUrlBodyTypeEnum = typeof SignTikTokUrlBodyTypeEnum[keyof typeof SignTikTokUrlBodyTypeEnum];

/**
 * 
 * @export
 * @interface SignTikTokUrlResponse
 */
export interface SignTikTokUrlResponse {
    /**
     * 
     * @type {number}
     * @memberof SignTikTokUrlResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlResponse
     */
    'message'?: string;
    /**
     * 
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray}
     * @memberof SignTikTokUrlResponse
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray;
}
/**
 * 
 * @export
 * @interface SignWebcastUrl200Response
 */
export interface SignWebcastUrl200Response {
    /**
     * 
     * @type {number}
     * @memberof SignWebcastUrl200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof SignWebcastUrl200Response
     */
    'message'?: string;
    /**
     * 
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray}
     * @memberof SignWebcastUrl200Response
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SoaxProxyRegion = {
    De: 'DE',
    Es: 'ES',
    Fr: 'FR',
    Gb: 'GB',
    Pl: 'PL'
} as const;

export type SoaxProxyRegion = typeof SoaxProxyRegion[keyof typeof SoaxProxyRegion];


/**
 * 
 * @export
 * @interface SolveResponseIconsResult
 */
export interface SolveResponseIconsResult {
    /**
     * 
     * @type {IconsResult}
     * @memberof SolveResponseIconsResult
     */
    'response': IconsResult | null;
    /**
     * 
     * @type {boolean}
     * @memberof SolveResponseIconsResult
     */
    'cached': boolean;
    /**
     * 
     * @type {number}
     * @memberof SolveResponseIconsResult
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface SolveResponsePuzzleResult
 */
export interface SolveResponsePuzzleResult {
    /**
     * 
     * @type {PuzzleResult}
     * @memberof SolveResponsePuzzleResult
     */
    'response': PuzzleResult | null;
    /**
     * 
     * @type {boolean}
     * @memberof SolveResponsePuzzleResult
     */
    'cached': boolean;
    /**
     * 
     * @type {number}
     * @memberof SolveResponsePuzzleResult
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface SolveResponseShapesResult
 */
export interface SolveResponseShapesResult {
    /**
     * 
     * @type {ShapesResult}
     * @memberof SolveResponseShapesResult
     */
    'response': ShapesResult | null;
    /**
     * 
     * @type {boolean}
     * @memberof SolveResponseShapesResult
     */
    'cached': boolean;
    /**
     * 
     * @type {number}
     * @memberof SolveResponseShapesResult
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface SolveResponseWhirlResult
 */
export interface SolveResponseWhirlResult {
    /**
     * 
     * @type {WhirlResult}
     * @memberof SolveResponseWhirlResult
     */
    'response': WhirlResult | null;
    /**
     * 
     * @type {boolean}
     * @memberof SolveResponseWhirlResult
     */
    'cached': boolean;
    /**
     * 
     * @type {number}
     * @memberof SolveResponseWhirlResult
     */
    'code': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StreamType = {
    HlsLd: 'hls_ld',
    HlsSd: 'hls_sd',
    FlvLd: 'flv_ld',
    FlvSd: 'flv_sd'
} as const;

export type StreamType = typeof StreamType[keyof typeof StreamType];


/**
 * 
 * @export
 * @interface TestAlertTargetResponse
 */
export interface TestAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof TestAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof TestAlertTargetResponse
     */
    'message'?: string;
    /**
     * 
     * @type {AlertTargetStatus}
     * @memberof TestAlertTargetResponse
     */
    'status'?: AlertTargetStatus;
    /**
     * 
     * @type {string}
     * @memberof TestAlertTargetResponse
     */
    'statusLabel'?: string;
}


/**
 * 
 * @export
 * @interface TikTokLiveUser
 */
export interface TikTokLiveUser {
    /**
     * 
     * @type {TikTokLiveUserRaw}
     * @memberof TikTokLiveUser
     */
    'raw': TikTokLiveUserRaw;
    /**
     * 
     * @type {PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString}
     * @memberof TikTokLiveUser
     */
    'room_info'?: PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString;
    /**
     * 
     * @type {TikTokLiveUserUser}
     * @memberof TikTokLiveUser
     */
    'user'?: TikTokLiveUserUser;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUser
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface TikTokLiveUserRaw
 */
export interface TikTokLiveUserRaw {
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserRaw
     */
    '_note': string;
}
/**
 * 
 * @export
 * @interface TikTokLiveUserUser
 */
export interface TikTokLiveUserUser {
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'sec_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'numeric_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'signature'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TikTokLiveUserUser
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TikTokLiveUserUser
     */
    'following'?: number;
    /**
     * 
     * @type {number}
     * @memberof TikTokLiveUserUser
     */
    'followers'?: number;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface TokenErrorResponse
 */
export interface TokenErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof TokenErrorResponse
     */
    'error_description'?: string;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'refresh_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token_type': TokenResponseTokenTypeEnum;
    /**
     * Access token lifetime in seconds
     * @type {number}
     * @memberof TokenResponse
     */
    'expires_in': number;
    /**
     * Refresh token lifetime in seconds
     * @type {number}
     * @memberof TokenResponse
     */
    'refresh_expires_in': number;
    /**
     * 
     * @type {Array<OAuthScope>}
     * @memberof TokenResponse
     */
    'scopes': Array<OAuthScope>;
}

export const TokenResponseTokenTypeEnum = {
    Bearer: 'Bearer'
} as const;

export type TokenResponseTokenTypeEnum = typeof TokenResponseTokenTypeEnum[keyof typeof TokenResponseTokenTypeEnum];

/**
 * 
 * @export
 * @interface UpdateKeyPayload
 */
export interface UpdateKeyPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateKeyPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateKeyResponse
 */
export interface UpdateKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ApiKey}
     * @memberof UpdateKeyResponse
     */
    'config'?: ApiKey;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponse
 */
export interface WebcastFeedResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponse
     */
    'status_code': number;
    /**
     * 
     * @type {WebcastFeedResponseExtra}
     * @memberof WebcastFeedResponse
     */
    'extra': WebcastFeedResponseExtra;
    /**
     * 
     * @type {Array<WebcastFeedResponseItem>}
     * @memberof WebcastFeedResponse
     */
    'data': Array<WebcastFeedResponseItem>;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseExtra
 */
export interface WebcastFeedResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'now': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseExtra
     */
    'unread_extra': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseExtra
     */
    'banner': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'max_time': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'cost': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseExtra
     */
    'is_backup': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastFeedResponseExtra
     */
    'has_more': boolean;
    /**
     * 
     * @type {WebcastFeedResponseExtraLogPb}
     * @memberof WebcastFeedResponseExtra
     */
    'log_pb': WebcastFeedResponseExtraLogPb;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseExtraLogPb
 */
export interface WebcastFeedResponseExtraLogPb {
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseExtraLogPb
     */
    'impr_id': string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseHashtag
 */
export interface WebcastFeedResponseHashtag {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseHashtag
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseHashtag
     */
    'title': string;
    /**
     * 
     * @type {WebcastFeedResponseRoomDataFeedRoomLabel}
     * @memberof WebcastFeedResponseHashtag
     */
    'image': WebcastFeedResponseRoomDataFeedRoomLabel;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseImage
 */
export interface WebcastFeedResponseImage {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastFeedResponseImage
     */
    'url_list': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseImage
     */
    'uri': string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseItem
 */
export interface WebcastFeedResponseItem {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseItem
     */
    'type': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseItem
     */
    'rid': string;
    /**
     * 
     * @type {WebcastFeedResponseRoomData}
     * @memberof WebcastFeedResponseItem
     */
    'data': WebcastFeedResponseRoomData;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseItem
     */
    'flare_info': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseItem
     */
    'room_event_tracking': string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseRoomData
 */
export interface WebcastFeedResponseRoomData {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomData
     */
    'id_str': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'status': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'owner_user_id': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomData
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'user_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'client_version': number;
    /**
     * 
     * @type {WebcastFeedResponseImage}
     * @memberof WebcastFeedResponseRoomData
     */
    'cover': WebcastFeedResponseImage;
    /**
     * 
     * @type {WebcastFeedResponseStreamUrl}
     * @memberof WebcastFeedResponseRoomData
     */
    'stream_url': WebcastFeedResponseStreamUrl;
    /**
     * 
     * @type {WebcastFeedResponseRoomDataStats}
     * @memberof WebcastFeedResponseRoomData
     */
    'stats': WebcastFeedResponseRoomDataStats;
    /**
     * 
     * @type {WebcastFeedResponseRoomDataFeedRoomLabel}
     * @memberof WebcastFeedResponseRoomData
     */
    'feed_room_label': WebcastFeedResponseRoomDataFeedRoomLabel;
    /**
     * 
     * @type {WebcastFeedResponseUser}
     * @memberof WebcastFeedResponseRoomData
     */
    'owner': WebcastFeedResponseUser;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastFeedResponseRoomData
     */
    'live_type_third_party': boolean;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: RecordStringBooleanOrNumberValue; }}
     * @memberof WebcastFeedResponseRoomData
     */
    'room_auth': { [key: string]: RecordStringBooleanOrNumberValue; };
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'like_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'anchor_tab_type': number;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseRoomData
     */
    'commerce_info': { [key: string]: any; };
    /**
     * 
     * @type {WebcastFeedResponseHashtag}
     * @memberof WebcastFeedResponseRoomData
     */
    'hashtag'?: WebcastFeedResponseHashtag;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomData
     */
    'live_room_mode': number;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseRoomData
     */
    'stream_url_filtered_info': { [key: string]: any; };
    /**
     * 
     * @type {WebcastFeedResponseRoomDataSquareCoverImg}
     * @memberof WebcastFeedResponseRoomData
     */
    'square_cover_img': WebcastFeedResponseRoomDataSquareCoverImg;
    /**
     * 
     * @type {WebcastFeedResponseRoomDataFeedRoomLabel}
     * @memberof WebcastFeedResponseRoomData
     */
    'rectangle_cover_img': WebcastFeedResponseRoomDataFeedRoomLabel;
    /**
     * 
     * @type {WebcastFeedResponseRoomDataSquareCoverImg}
     * @memberof WebcastFeedResponseRoomData
     */
    'blurred_cover': WebcastFeedResponseRoomDataSquareCoverImg;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseRoomData
     */
    'multi_stream_url': { [key: string]: any; };
    /**
     * 
     * @type {WebcastFeedResponseRoomDataGameTagDetail}
     * @memberof WebcastFeedResponseRoomData
     */
    'game_tag_detail': WebcastFeedResponseRoomDataGameTagDetail;
    /**
     * 
     * @type {WebcastFeedResponseRoomDataTaxonomyTagInfo}
     * @memberof WebcastFeedResponseRoomData
     */
    'taxonomy_tag_info': WebcastFeedResponseRoomDataTaxonomyTagInfo;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseRoomDataFeedRoomLabel
 */
export interface WebcastFeedResponseRoomDataFeedRoomLabel {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastFeedResponseRoomDataFeedRoomLabel
     */
    'url_list': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataFeedRoomLabel
     */
    'uri': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataFeedRoomLabel
     */
    'avg_color': string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseRoomDataGameTagDetail
 */
export interface WebcastFeedResponseRoomDataGameTagDetail {
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataGameTagDetail
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataGameTagDetail
     */
    'starling_key': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataGameTagDetail
     */
    'game_tag_name': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataGameTagDetail
     */
    'game_tag_id': number;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseRoomDataSquareCoverImg
 */
export interface WebcastFeedResponseRoomDataSquareCoverImg {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'url_list': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'uri': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'avg_color': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataSquareCoverImg
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseRoomDataStats
 */
export interface WebcastFeedResponseRoomDataStats {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataStats
     */
    'comment_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataStats
     */
    'enter_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseRoomDataStats
     */
    'total_user': number;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseRoomDataTaxonomyTagInfo
 */
export interface WebcastFeedResponseRoomDataTaxonomyTagInfo {
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseRoomDataTaxonomyTagInfo
     */
    'level2_tag': string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseStreamUrl
 */
export interface WebcastFeedResponseStreamUrl {
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'rtmp_pull_url': string;
    /**
     * 
     * @type {WebcastFeedResponseStreamUrlFlvPullUrl}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'flv_pull_url': WebcastFeedResponseStreamUrlFlvPullUrl;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'flv_pull_url_params'?: { [key: string]: string; };
    /**
     * 
     * @type {WebcastFeedResponseStreamUrlLiveCoreSdkData}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'live_core_sdk_data'?: WebcastFeedResponseStreamUrlLiveCoreSdkData;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'stream_size_width': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseStreamUrl
     */
    'stream_size_height': number;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseStreamUrlFlvPullUrl
 */
export interface WebcastFeedResponseStreamUrlFlvPullUrl {
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlFlvPullUrl
     */
    'SD1'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlFlvPullUrl
     */
    'SD2'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlFlvPullUrl
     */
    'HD1'?: string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseStreamUrlLiveCoreSdkData
 */
export interface WebcastFeedResponseStreamUrlLiveCoreSdkData {
    /**
     * 
     * @type {WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkData
     */
    'pull_data': WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData
 */
export interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData {
    /**
     * 
     * @type {WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData
     */
    'options': WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullData
     */
    'stream_data': string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions
 */
export interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions {
    /**
     * 
     * @type {WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptions
     */
    'default_quality': WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality
 */
export interface WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality {
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality
     */
    'sdk_key': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseStreamUrlLiveCoreSdkDataPullDataOptionsDefaultQuality
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseUser
 */
export interface WebcastFeedResponseUser {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'bio_description': string;
    /**
     * 
     * @type {WebcastFeedResponseImage}
     * @memberof WebcastFeedResponseUser
     */
    'avatar_thumb': WebcastFeedResponseImage;
    /**
     * 
     * @type {WebcastFeedResponseImage}
     * @memberof WebcastFeedResponseUser
     */
    'avatar_medium': WebcastFeedResponseImage;
    /**
     * 
     * @type {WebcastFeedResponseImage}
     * @memberof WebcastFeedResponseUser
     */
    'avatar_large': WebcastFeedResponseImage;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseUser
     */
    'status': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseUser
     */
    'modify_time': number;
    /**
     * 
     * @type {WebcastFeedResponseUserFollowInfo}
     * @memberof WebcastFeedResponseUser
     */
    'follow_info': WebcastFeedResponseUserFollowInfo;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseUser
     */
    'pay_grade': { [key: string]: any; };
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastFeedResponseUser
     */
    'user_attr': { [key: string]: any; };
    /**
     * 
     * @type {WebcastFeedResponseUserOwnRoom}
     * @memberof WebcastFeedResponseUser
     */
    'own_room': WebcastFeedResponseUserOwnRoom;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'display_id': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'sec_uid': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedResponseUser
     */
    'id_str': string;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseUserFollowInfo
 */
export interface WebcastFeedResponseUserFollowInfo {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseUserFollowInfo
     */
    'follower_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedResponseUserFollowInfo
     */
    'following_count': number;
}
/**
 * 
 * @export
 * @interface WebcastFeedResponseUserOwnRoom
 */
export interface WebcastFeedResponseUserOwnRoom {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastFeedResponseUserOwnRoom
     */
    'room_ids_str': Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof WebcastFeedResponseUserOwnRoom
     */
    'room_ids': Array<number>;
}
/**
 * 
 * @export
 * @interface WebcastFeedRouteOutput
 */
export interface WebcastFeedRouteOutput {
    /**
     * 
     * @type {WebcastFeedResponse}
     * @memberof WebcastFeedRouteOutput
     */
    'data': WebcastFeedResponse;
}
/**
 * 
 * @export
 * @interface WebcastFeedRouteResponse
 */
export interface WebcastFeedRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastFeedRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastFeedRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastFeedRouteOutput}
     * @memberof WebcastFeedRouteResponse
     */
    'response'?: WebcastFeedRouteOutput;
    /**
     * 
     * @type {OxyLabsProxyRegion}
     * @memberof WebcastFeedRouteResponse
     */
    'region': OxyLabsProxyRegion;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebcastFetchPlatform = {
    Mobile: 'mobile',
    Web: 'web'
} as const;

export type WebcastFetchPlatform = typeof WebcastFetchPlatform[keyof typeof WebcastFetchPlatform];


/**
 * 
 * @export
 * @interface WebcastGiftInfoOutput
 */
export interface WebcastGiftInfoOutput {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastGiftInfoOutput
     */
    'data': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface WebcastGiftInfoRouteResponse
 */
export interface WebcastGiftInfoRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastGiftInfoRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastGiftInfoRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastGiftInfoOutput}
     * @memberof WebcastGiftInfoRouteResponse
     */
    'response'?: WebcastGiftInfoOutput;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListResponse
 */
export interface WebcastHashtagListResponse {
    /**
     * 
     * @type {WebcastHashtagListResponseData}
     * @memberof WebcastHashtagListResponse
     */
    'data': WebcastHashtagListResponseData;
    /**
     * 
     * @type {WebcastHashtagListResponseExtra}
     * @memberof WebcastHashtagListResponse
     */
    'extra': WebcastHashtagListResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListResponseData
 */
export interface WebcastHashtagListResponseData {
    /**
     * 
     * @type {WebcastHashtagListResponseHashtag}
     * @memberof WebcastHashtagListResponseData
     */
    'game_hashtag': WebcastHashtagListResponseHashtag;
    /**
     * 
     * @type {Array<WebcastHashtagListResponseGameTag>}
     * @memberof WebcastHashtagListResponseData
     */
    'game_tag_list': Array<WebcastHashtagListResponseGameTag>;
    /**
     * 
     * @type {Array<WebcastHashtagListResponseHashtag>}
     * @memberof WebcastHashtagListResponseData
     */
    'hashtag': Array<WebcastHashtagListResponseHashtag>;
    /**
     * 
     * @type {Array<WebcastHashtagListResponseHashtag>}
     * @memberof WebcastHashtagListResponseData
     */
    'live_studio_hashtag': Array<WebcastHashtagListResponseHashtag>;
    /**
     * 
     * @type {Array<WebcastHashtagListResponseHashtag>}
     * @memberof WebcastHashtagListResponseData
     */
    'live_voice_hashtag': Array<WebcastHashtagListResponseHashtag>;
    /**
     * 
     * @type {Array<WebcastHashtagListResponseHashtag>}
     * @memberof WebcastHashtagListResponseData
     */
    'third_party_hashtag': Array<WebcastHashtagListResponseHashtag>;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListResponseExtra
 */
export interface WebcastHashtagListResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListResponseGameCategory
 */
export interface WebcastHashtagListResponseGameCategory {
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseGameCategory
     */
    'game_type': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseGameCategory
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListResponseGameTag
 */
export interface WebcastHashtagListResponseGameTag {
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'bundle_id': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'full_name': string;
    /**
     * 
     * @type {Array<WebcastHashtagListResponseGameCategory>}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'game_category': Array<WebcastHashtagListResponseGameCategory>;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'gar': Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'hashtag_id': Array<any>;
    /**
     * 
     * @type {Array<WebcastHashtagListResponseHashtagSimple>}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'hashtag_list': Array<WebcastHashtagListResponseHashtagSimple>;
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'is_new_game': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'landscape': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'package_name': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'short_name': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseGameTag
     */
    'show_name': string;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListResponseHashtag
 */
export interface WebcastHashtagListResponseHashtag {
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseHashtag
     */
    'id': number;
    /**
     * 
     * @type {WebcastHashtagListResponseImage}
     * @memberof WebcastHashtagListResponseHashtag
     */
    'image': WebcastHashtagListResponseImage;
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseHashtag
     */
    'namespace': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseHashtag
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListResponseHashtagSimple
 */
export interface WebcastHashtagListResponseHashtagSimple {
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseHashtagSimple
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseHashtagSimple
     */
    'namespace': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseHashtagSimple
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListResponseImage
 */
export interface WebcastHashtagListResponseImage {
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseImage
     */
    'avg_color': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseImage
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseImage
     */
    'image_type': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastHashtagListResponseImage
     */
    'is_animated': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseImage
     */
    'open_web_url': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastHashtagListResponseImage
     */
    'uri': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastHashtagListResponseImage
     */
    'url_list': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof WebcastHashtagListResponseImage
     */
    'width': number;
}
/**
 * 
 * @export
 * @interface WebcastHashtagListRouteOutput
 */
export interface WebcastHashtagListRouteOutput {
    /**
     * 
     * @type {WebcastHashtagListResponse}
     * @memberof WebcastHashtagListRouteOutput
     */
    'data': WebcastHashtagListResponse;
}
/**
 * 
 * @export
 * @interface WebcastIsLiveOutput
 */
export interface WebcastIsLiveOutput {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: RecordStringIsLiveBooleanRoomIdStringOrNullValue; }}
     * @memberof WebcastIsLiveOutput
     */
    'data'?: { [key: string]: RecordStringIsLiveBooleanRoomIdStringOrNullValue; };
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponse
 */
export interface WebcastLiveAnalyticsVideoDetailResponse {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseData}
     * @memberof WebcastLiveAnalyticsVideoDetailResponse
     */
    'data': WebcastLiveAnalyticsVideoDetailResponseData;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseExtra}
     * @memberof WebcastLiveAnalyticsVideoDetailResponse
     */
    'extra': WebcastLiveAnalyticsVideoDetailResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseAnalytics
 */
export interface WebcastLiveAnalyticsVideoDetailResponseAnalytics {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseEarnings}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseAnalytics
     */
    'earnings': WebcastLiveAnalyticsVideoDetailResponseEarnings;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseInteraction}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseAnalytics
     */
    'interaction': WebcastLiveAnalyticsVideoDetailResponseInteraction;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseViews}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseAnalytics
     */
    'views': WebcastLiveAnalyticsVideoDetailResponseViews;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseAverageWatchTime
 */
export interface WebcastLiveAnalyticsVideoDetailResponseAverageWatchTime {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseAverageWatchTime
     */
    'follower': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseAverageWatchTime
     */
    'non_follower': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseBehaviorSummary
 */
export interface WebcastLiveAnalyticsVideoDetailResponseBehaviorSummary {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseCohostSummary}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseBehaviorSummary
     */
    'cohost_summary': WebcastLiveAnalyticsVideoDetailResponseCohostSummary;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseBehaviorSummary
     */
    'multi_guest_summary': WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseCohostSummary
 */
export interface WebcastLiveAnalyticsVideoDetailResponseCohostSummary {
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCohostSummary
     */
    'cohost_rank': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCohostSummary
     */
    'total_anchor': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCohostSummary
     */
    'total_diamonds': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCohostSummary
     */
    'total_views': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseCommentsInfo
 */
export interface WebcastLiveAnalyticsVideoDetailResponseCommentsInfo {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCommentsInfo
     */
    'comment_cnt': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCommentsInfo
     */
    'entry_location': string;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCommentsInfo
     */
    'show_entry': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCommentsInfo
     */
    'sub_title': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseCommentsInfo
     */
    'top_users': Array<any>;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseData
 */
export interface WebcastLiveAnalyticsVideoDetailResponseData {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseAnalytics}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'analytics': WebcastLiveAnalyticsVideoDetailResponseAnalytics;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseAverageWatchTime}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'average_watch_time': WebcastLiveAnalyticsVideoDetailResponseAverageWatchTime;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseBehaviorSummary}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'behavior_summary': WebcastLiveAnalyticsVideoDetailResponseBehaviorSummary;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseCommentsInfo}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'comments_info': WebcastLiveAnalyticsVideoDetailResponseCommentsInfo;
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'cover_image_url': string;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseDetailedMetrics}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'detailed_metrics': WebcastLiveAnalyticsVideoDetailResponseDetailedMetrics;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'duration': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'end_time': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'is_first_live': boolean;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseNewAnalytics}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'new_analytics': WebcastLiveAnalyticsVideoDetailResponseNewAnalytics;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'pause_duration': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'start_time': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'title': string;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseTrafficInfo}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'traffic_info': WebcastLiveAnalyticsVideoDetailResponseTrafficInfo;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseViewerInfo}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'viewer_info': WebcastLiveAnalyticsVideoDetailResponseViewerInfo;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseViewsBySection}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseData
     */
    'views_by_setion': WebcastLiveAnalyticsVideoDetailResponseViewsBySection;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseDetailedMetrics
 */
export interface WebcastLiveAnalyticsVideoDetailResponseDetailedMetrics {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseFollowerMetric}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseDetailedMetrics
     */
    'commenter': WebcastLiveAnalyticsVideoDetailResponseFollowerMetric;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseFollowerMetric}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseDetailedMetrics
     */
    'gifters': WebcastLiveAnalyticsVideoDetailResponseFollowerMetric;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseFollowerMetric}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseDetailedMetrics
     */
    'viewers': WebcastLiveAnalyticsVideoDetailResponseFollowerMetric;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails
 */
export interface WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails
     */
    'gift_fan_tickets_percentage': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails
     */
    'multi_guest_fan_tickets_percentage': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails
     */
    'star_comment_fan_tickets_percentage': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails
     */
    'star_comment_qualification': boolean;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseEarnings
 */
export interface WebcastLiveAnalyticsVideoDetailResponseEarnings {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseEarnings
     */
    'diamonds': number;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseEarnings
     */
    'diamonds_details': WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseEarnings
     */
    'gifters': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseExtra
 */
export interface WebcastLiveAnalyticsVideoDetailResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseFollowerMetric
 */
export interface WebcastLiveAnalyticsVideoDetailResponseFollowerMetric {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseFollowerMetric
     */
    'follower': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseFollowerMetric
     */
    'non_follower': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseInteraction
 */
export interface WebcastLiveAnalyticsVideoDetailResponseInteraction {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseInteraction
     */
    'comment': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseInteraction
     */
    'likes': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseInteraction
     */
    'new_followers': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseInteraction
     */
    'shares': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary
 */
export interface WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary {
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary
     */
    'multi_guest_rank': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary
     */
    'multi_guest_show_type': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary
     */
    'total_diamonds': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary
     */
    'total_duration': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary
     */
    'total_guest': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseMultiGuestSummary
     */
    'total_points': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseNewAnalytics
 */
export interface WebcastLiveAnalyticsVideoDetailResponseNewAnalytics {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseNewEarnings}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewAnalytics
     */
    'earnings': WebcastLiveAnalyticsVideoDetailResponseNewEarnings;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseNewInteraction}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewAnalytics
     */
    'interaction': WebcastLiveAnalyticsVideoDetailResponseNewInteraction;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseNewViews}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewAnalytics
     */
    'views': WebcastLiveAnalyticsVideoDetailResponseNewViews;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseNewEarnings
 */
export interface WebcastLiveAnalyticsVideoDetailResponseNewEarnings {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewEarnings
     */
    'diamonds': number;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewEarnings
     */
    'diamonds_details': WebcastLiveAnalyticsVideoDetailResponseDiamondsDetails;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewEarnings
     */
    'last_diamonds': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseNewInteraction
 */
export interface WebcastLiveAnalyticsVideoDetailResponseNewInteraction {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'comment': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'gifters': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'last_comment': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'last_gifters': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'last_likes': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'last_new_followers': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'last_shares': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'likes': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'new_followers': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'shares': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewInteraction
     */
    'top_interaction': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseNewViews
 */
export interface WebcastLiveAnalyticsVideoDetailResponseNewViews {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'anchor_live_acu': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'average_watch_time': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'last_anchor_live_acu': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'last_average_watch_time': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'last_three_min_total_views': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'last_top_viewer_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'last_total_views': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'last_unique_viewers': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'three_min_total_views': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'top_viewer_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'total_views': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseNewViews
     */
    'unique_viewers': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseRegionEntry
 */
export interface WebcastLiveAnalyticsVideoDetailResponseRegionEntry {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseRegionEntry
     */
    'percent': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseRegionEntry
     */
    'region_name': string;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseTrafficConversion
 */
export interface WebcastLiveAnalyticsVideoDetailResponseTrafficConversion {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficConversion
     */
    'gifters': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficConversion
     */
    'impression_viewers': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficConversion
     */
    'unique_viewers': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseTrafficInfo
 */
export interface WebcastLiveAnalyticsVideoDetailResponseTrafficInfo {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseTrafficTotal}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficInfo
     */
    'total': WebcastLiveAnalyticsVideoDetailResponseTrafficTotal;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseTrafficConversion}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficInfo
     */
    'traffic_conversion': WebcastLiveAnalyticsVideoDetailResponseTrafficConversion;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseTrafficTotal
 */
export interface WebcastLiveAnalyticsVideoDetailResponseTrafficTotal {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficTotal
     */
    'following': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficTotal
     */
    'live_recomm': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficTotal
     */
    'others': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficTotal
     */
    'share': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficTotal
     */
    'video_recomm': number;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseVideoRecommInfo}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseTrafficTotal
     */
    'video_recomm_info': WebcastLiveAnalyticsVideoDetailResponseVideoRecommInfo;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseVideoRecommInfo
 */
export interface WebcastLiveAnalyticsVideoDetailResponseVideoRecommInfo {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseVideoRecommInfo
     */
    'total_views': number;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseVideoRecommInfo
     */
    'video_info': Array<any>;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseViewerInfo
 */
export interface WebcastLiveAnalyticsVideoDetailResponseViewerInfo {
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewerInfo
     */
    'gift_rank': Array<any>;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseViewerPortrait}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewerInfo
     */
    'viewer_portrait': WebcastLiveAnalyticsVideoDetailResponseViewerPortrait;
    /**
     * 
     * @type {Array<WebcastLiveAnalyticsVideoDetailResponseWatcherRank>}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewerInfo
     */
    'watcher_rank': Array<WebcastLiveAnalyticsVideoDetailResponseWatcherRank>;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseViewerPortrait
 */
export interface WebcastLiveAnalyticsVideoDetailResponseViewerPortrait {
    /**
     * 
     * @type {Array<WebcastLiveAnalyticsVideoDetailResponseViewersAge>}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewerPortrait
     */
    'viewers_age': Array<WebcastLiveAnalyticsVideoDetailResponseViewersAge>;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseViewersGender}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewerPortrait
     */
    'viewers_gender': WebcastLiveAnalyticsVideoDetailResponseViewersGender;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponseViewersRegion}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewerPortrait
     */
    'viewers_region': WebcastLiveAnalyticsVideoDetailResponseViewersRegion;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseViewersAge
 */
export interface WebcastLiveAnalyticsVideoDetailResponseViewersAge {
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewersAge
     */
    'age_section': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewersAge
     */
    'percent': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseViewersGender
 */
export interface WebcastLiveAnalyticsVideoDetailResponseViewersGender {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewersGender
     */
    'female_percent': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewersGender
     */
    'male_percent': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseViewersRegion
 */
export interface WebcastLiveAnalyticsVideoDetailResponseViewersRegion {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewersRegion
     */
    'others': number;
    /**
     * 
     * @type {Array<WebcastLiveAnalyticsVideoDetailResponseRegionEntry>}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewersRegion
     */
    'top_viewers_region_list': Array<WebcastLiveAnalyticsVideoDetailResponseRegionEntry>;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseViews
 */
export interface WebcastLiveAnalyticsVideoDetailResponseViews {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViews
     */
    'anchor_live_acu': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViews
     */
    'average_watch_time': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViews
     */
    'top_viewer_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViews
     */
    'total_views': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViews
     */
    'unique_viewers': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseViewsBySection
 */
export interface WebcastLiveAnalyticsVideoDetailResponseViewsBySection {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewsBySection
     */
    'following': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewsBySection
     */
    'live_recomm': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewsBySection
     */
    'others': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewsBySection
     */
    'share': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseViewsBySection
     */
    'video_recomm': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailResponseWatcherRank
 */
export interface WebcastLiveAnalyticsVideoDetailResponseWatcherRank {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseWatcherRank
     */
    'user': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoDetailResponseWatcherRank
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoDetailRouteOutput
 */
export interface WebcastLiveAnalyticsVideoDetailRouteOutput {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoDetailResponse}
     * @memberof WebcastLiveAnalyticsVideoDetailRouteOutput
     */
    'data': WebcastLiveAnalyticsVideoDetailResponse;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoListResponse
 */
export interface WebcastLiveAnalyticsVideoListResponse {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoListResponseData}
     * @memberof WebcastLiveAnalyticsVideoListResponse
     */
    'data': WebcastLiveAnalyticsVideoListResponseData;
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoListResponseExtra}
     * @memberof WebcastLiveAnalyticsVideoListResponse
     */
    'extra': WebcastLiveAnalyticsVideoListResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoListResponseData
 */
export interface WebcastLiveAnalyticsVideoListResponseData {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponseData
     */
    'total': number;
    /**
     * 
     * @type {Array<WebcastLiveAnalyticsVideoListResponseVideo>}
     * @memberof WebcastLiveAnalyticsVideoListResponseData
     */
    'video_list': Array<WebcastLiveAnalyticsVideoListResponseVideo>;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoListResponseExtra
 */
export interface WebcastLiveAnalyticsVideoListResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoListResponseVideo
 */
export interface WebcastLiveAnalyticsVideoListResponseVideo {
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'cover': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'diamonds': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'duration': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'end_time': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'new_followers': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'room_id': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'start_time': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastLiveAnalyticsVideoListResponseVideo
     */
    'views': number;
}
/**
 * 
 * @export
 * @interface WebcastLiveAnalyticsVideoListRouteOutput
 */
export interface WebcastLiveAnalyticsVideoListRouteOutput {
    /**
     * 
     * @type {WebcastLiveAnalyticsVideoListResponse}
     * @memberof WebcastLiveAnalyticsVideoListRouteOutput
     */
    'data': WebcastLiveAnalyticsVideoListResponse;
}
/**
 * 
 * @export
 * @interface WebcastRegionRankingsOutput
 */
export interface WebcastRegionRankingsOutput {
    /**
     * 
     * @type {Array<PartialWebcastRegionRankingsOutputRank>}
     * @memberof WebcastRegionRankingsOutput
     */
    'ranks': Array<PartialWebcastRegionRankingsOutputRank>;
    /**
     * 
     * @type {string}
     * @memberof WebcastRegionRankingsOutput
     */
    'rank_title': string | null;
    /**
     * 
     * @type {string}
     * @memberof WebcastRegionRankingsOutput
     */
    'rank_type': string | null;
    /**
     * 
     * @type {string}
     * @memberof WebcastRegionRankingsOutput
     */
    'resets_at': string | null;
    /**
     * 
     * @type {number}
     * @memberof WebcastRegionRankingsOutput
     */
    'resets_in': number | null;
}
/**
 * 
 * @export
 * @interface WebcastRegionRankingsResponse
 */
export interface WebcastRegionRankingsResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastRegionRankingsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRegionRankingsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastRegionRankingsOutput}
     * @memberof WebcastRegionRankingsResponse
     */
    'response'?: WebcastRegionRankingsOutput;
    /**
     * 
     * @type {OxyLabsProxyRegion}
     * @memberof WebcastRegionRankingsResponse
     */
    'region': OxyLabsProxyRegion;
}


/**
 * 
 * @export
 * @interface WebcastRoomAdminListResponse
 */
export interface WebcastRoomAdminListResponse {
    /**
     * 
     * @type {Array<WebcastRoomAdminListResponseAdmin>}
     * @memberof WebcastRoomAdminListResponse
     */
    'data': Array<WebcastRoomAdminListResponseAdmin>;
    /**
     * 
     * @type {WebcastRoomAdminListResponseExtra}
     * @memberof WebcastRoomAdminListResponse
     */
    'extra': WebcastRoomAdminListResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomAdminListResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomAdminListResponseAdmin
 */
export interface WebcastRoomAdminListResponseAdmin {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: number; }}
     * @memberof WebcastRoomAdminListResponseAdmin
     */
    'admin_permissions': { [key: string]: number; };
    /**
     * 
     * @type {WebcastRoomAdminListResponseImage}
     * @memberof WebcastRoomAdminListResponseAdmin
     */
    'avatar_large': WebcastRoomAdminListResponseImage;
    /**
     * 
     * @type {WebcastRoomAdminListResponseImage}
     * @memberof WebcastRoomAdminListResponseAdmin
     */
    'avatar_thumb': WebcastRoomAdminListResponseImage;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomAdminListResponseAdmin
     */
    'display_id': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomAdminListResponseAdmin
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomAdminListResponseAdmin
     */
    'id_str': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomAdminListResponseAdmin
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomAdminListResponseAdmin
     */
    'sec_uid': string;
}
/**
 * 
 * @export
 * @interface WebcastRoomAdminListResponseExtra
 */
export interface WebcastRoomAdminListResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomAdminListResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomAdminListResponseImage
 */
export interface WebcastRoomAdminListResponseImage {
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomAdminListResponseImage
     */
    'avg_color': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomAdminListResponseImage
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomAdminListResponseImage
     */
    'image_type': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomAdminListResponseImage
     */
    'is_animated': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomAdminListResponseImage
     */
    'open_web_url': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomAdminListResponseImage
     */
    'uri': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastRoomAdminListResponseImage
     */
    'url_list': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomAdminListResponseImage
     */
    'width': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomAdminListRouteOutput
 */
export interface WebcastRoomAdminListRouteOutput {
    /**
     * 
     * @type {WebcastRoomAdminListResponse}
     * @memberof WebcastRoomAdminListRouteOutput
     */
    'data': WebcastRoomAdminListResponse;
}
/**
 * 
 * @export
 * @interface WebcastRoomAdminUpdateResponse
 */
export interface WebcastRoomAdminUpdateResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastRoomAdminUpdateResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {WebcastRoomAdminUpdateResponseExtra}
     * @memberof WebcastRoomAdminUpdateResponse
     */
    'extra': WebcastRoomAdminUpdateResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomAdminUpdateResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomAdminUpdateResponseExtra
 */
export interface WebcastRoomAdminUpdateResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomAdminUpdateResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomAdminUpdateRouteOutput
 */
export interface WebcastRoomAdminUpdateRouteOutput {
    /**
     * 
     * @type {WebcastRoomAdminUpdateResponse}
     * @memberof WebcastRoomAdminUpdateRouteOutput
     */
    'data': WebcastRoomAdminUpdateResponse;
}
/**
 * 
 * @export
 * @interface WebcastRoomChatPayload
 */
export interface WebcastRoomChatPayload {
    /**
     * The chat message content to send
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'content': string;
    /**
     * The room ID to send the chat to (either this or targetUniqueId is required)
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'targetRoomId'?: string;
    /**
     * The username of the room to send the chat to (either this or targetRoomId is required)
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'targetUniqueId'?: string;
}
/**
 * 
 * @export
 * @interface WebcastRoomChatPayloadV1
 */
export interface WebcastRoomChatPayloadV1 {
    /**
     * The chat message content to send
     * @type {string}
     * @memberof WebcastRoomChatPayloadV1
     */
    'content': string;
    /**
     * The room ID to send the chat to (either this or targetUniqueId is required)
     * @type {string}
     * @memberof WebcastRoomChatPayloadV1
     */
    'targetRoomId'?: string;
    /**
     * The username of the room to send the chat to (either this or targetRoomId is required)
     * @type {string}
     * @memberof WebcastRoomChatPayloadV1
     */
    'targetUniqueId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomChatPayloadV1
     * @deprecated
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomChatPayloadV1
     * @deprecated
     */
    'ttTargetIdc'?: string;
}
/**
 * 
 * @export
 * @interface WebcastRoomChatRouteResponse
 */
export interface WebcastRoomChatRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomChatRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomChatRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {any}
     * @memberof WebcastRoomChatRouteResponse
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface WebcastRoomCommentsToggleResponse
 */
export interface WebcastRoomCommentsToggleResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastRoomCommentsToggleResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {WebcastRoomCommentsToggleResponseExtra}
     * @memberof WebcastRoomCommentsToggleResponse
     */
    'extra': WebcastRoomCommentsToggleResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomCommentsToggleResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomCommentsToggleResponseExtra
 */
export interface WebcastRoomCommentsToggleResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomCommentsToggleResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomCommentsToggleRouteOutput
 */
export interface WebcastRoomCommentsToggleRouteOutput {
    /**
     * 
     * @type {WebcastRoomCommentsToggleResponse}
     * @memberof WebcastRoomCommentsToggleRouteOutput
     */
    'data': WebcastRoomCommentsToggleResponse;
}
/**
 * 
 * @export
 * @interface WebcastRoomIdRouteResponse
 */
export interface WebcastRoomIdRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomIdRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomIdRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomIdRouteResponse
     */
    'ok': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastRoomIdRouteResponse
     */
    'routes_attempted': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomIdRouteResponse
     */
    'is_live'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomIdRouteResponse
     */
    'room_id'?: string;
}
/**
 * 
 * @export
 * @interface WebcastRoomInfoRouteResponse
 */
export interface WebcastRoomInfoRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'ok': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'routes_attempted': Array<string>;
    /**
     * 
     * @type {TikTokLiveUser}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'data': TikTokLiveUser | null;
}
/**
 * 
 * @export
 * @interface WebcastRoomKickUserResponse
 */
export interface WebcastRoomKickUserResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastRoomKickUserResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {WebcastRoomKickUserResponseExtra}
     * @memberof WebcastRoomKickUserResponse
     */
    'extra': WebcastRoomKickUserResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomKickUserResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomKickUserResponseExtra
 */
export interface WebcastRoomKickUserResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomKickUserResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomKickUserRouteOutput
 */
export interface WebcastRoomKickUserRouteOutput {
    /**
     * 
     * @type {WebcastRoomKickUserResponse}
     * @memberof WebcastRoomKickUserRouteOutput
     */
    'data': WebcastRoomKickUserResponse;
}
/**
 * 
 * @export
 * @interface WebcastRoomKickedUsersResponse
 */
export interface WebcastRoomKickedUsersResponse {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof WebcastRoomKickedUsersResponse
     */
    'data': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {WebcastRoomKickedUsersResponseExtra}
     * @memberof WebcastRoomKickedUsersResponse
     */
    'extra': WebcastRoomKickedUsersResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomKickedUsersResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomKickedUsersResponseExtra
 */
export interface WebcastRoomKickedUsersResponseExtra {
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomKickedUsersResponseExtra
     */
    'has_more': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomKickedUsersResponseExtra
     */
    'next_cursor': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomKickedUsersResponseExtra
     */
    'now': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomKickedUsersResponseExtra
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomKickedUsersRouteOutput
 */
export interface WebcastRoomKickedUsersRouteOutput {
    /**
     * 
     * @type {WebcastRoomKickedUsersResponse}
     * @memberof WebcastRoomKickedUsersRouteOutput
     */
    'data': WebcastRoomKickedUsersResponse;
}
/**
 * 
 * @export
 * @interface WebcastRoomMuteUserResponse
 */
export interface WebcastRoomMuteUserResponse {
    /**
     * 
     * @type {WebcastRoomMuteUserResponseData}
     * @memberof WebcastRoomMuteUserResponse
     */
    'data': WebcastRoomMuteUserResponseData;
    /**
     * 
     * @type {WebcastRoomMuteUserResponseExtra}
     * @memberof WebcastRoomMuteUserResponse
     */
    'extra': WebcastRoomMuteUserResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMuteUserResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMuteUserResponseData
 */
export interface WebcastRoomMuteUserResponseData {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMuteUserResponseData
     */
    'actual_duration': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMuteUserResponseData
     */
    'max_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMuteUserResponseData
     */
    'room_id': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMuteUserResponseData
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMuteUserResponseData
     */
    'user_id': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMuteUserResponseExtra
 */
export interface WebcastRoomMuteUserResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMuteUserResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMuteUserRouteOutput
 */
export interface WebcastRoomMuteUserRouteOutput {
    /**
     * 
     * @type {WebcastRoomMuteUserResponse}
     * @memberof WebcastRoomMuteUserRouteOutput
     */
    'data': WebcastRoomMuteUserResponse;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponse
 */
export interface WebcastRoomMutedUsersResponse {
    /**
     * 
     * @type {Array<WebcastRoomMutedUsersResponseUser>}
     * @memberof WebcastRoomMutedUsersResponse
     */
    'data': Array<WebcastRoomMutedUsersResponseUser>;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseExtra}
     * @memberof WebcastRoomMutedUsersResponse
     */
    'extra': WebcastRoomMutedUsersResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseBadge
 */
export interface WebcastRoomMutedUsersResponseBadge {
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'OpenWebURL'?: string;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseBadgeCombine}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'combine'?: WebcastRoomMutedUsersResponseBadgeCombine;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'display': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'display_status': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'display_type': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'exhibition_type': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'greyed_by_client': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'is_customized': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'priority_type': number;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponsePrivilegeLogExtra}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'privilege_log_extra': WebcastRoomMutedUsersResponsePrivilegeLogExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'scene_type': number;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseBadgeText}
     * @memberof WebcastRoomMutedUsersResponseBadge
     */
    'text'?: WebcastRoomMutedUsersResponseBadgeText;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseBadgeBackground
 */
export interface WebcastRoomMutedUsersResponseBadgeBackground {
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseBadgeBackground
     */
    'background_color_code': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseBadgeBackground
     */
    'border_color_code': string;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseImage}
     * @memberof WebcastRoomMutedUsersResponseBadgeBackground
     */
    'image': WebcastRoomMutedUsersResponseImage;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseImage}
     * @memberof WebcastRoomMutedUsersResponseBadgeBackground
     */
    'left_side_image': WebcastRoomMutedUsersResponseImage;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseBadgeCombine
 */
export interface WebcastRoomMutedUsersResponseBadgeCombine {
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseBadgeBackground}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'background': WebcastRoomMutedUsersResponseBadgeBackground;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'background_auto_mirrored': boolean;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseBadgeBackground}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'background_dark_mode': WebcastRoomMutedUsersResponseBadgeBackground;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'display_type': number;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseImage}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'icon': WebcastRoomMutedUsersResponseImage;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'icon_auto_mirrored': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'multi_guest_show_style': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'personal_card_show_style': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'public_screen_show_style': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'ranklist_online_audience_show_style': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'str': string;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseBadgeText}
     * @memberof WebcastRoomMutedUsersResponseBadgeCombine
     */
    'text': WebcastRoomMutedUsersResponseBadgeText;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseBadgeText
 */
export interface WebcastRoomMutedUsersResponseBadgeText {
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseBadgeText
     */
    'default_pattern': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseBadgeText
     */
    'display_type'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseBadgeText
     */
    'key': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseBadgeText
     */
    'pieces': Array<any>;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseEnigmaInfo
 */
export interface WebcastRoomMutedUsersResponseEnigmaInfo {
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseEnigmaInfo
     */
    'is_enigma_mask_on': boolean;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseExtra
 */
export interface WebcastRoomMutedUsersResponseExtra {
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseExtra
     */
    'datas': Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseExtra
     */
    'has_more': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseExtra
     */
    'max_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseExtra
     */
    'next_cursor': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseExtra
     */
    'now': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseExtra
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseFollowInfo
 */
export interface WebcastRoomMutedUsersResponseFollowInfo {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseFollowInfo
     */
    'follow_status': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseFollowInfo
     */
    'follower_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseFollowInfo
     */
    'following_count': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseFollowInfo
     */
    'push_status': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseImage
 */
export interface WebcastRoomMutedUsersResponseImage {
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseImage
     */
    'avg_color': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseImage
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseImage
     */
    'image_type': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseImage
     */
    'is_animated': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseImage
     */
    'open_web_url': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseImage
     */
    'uri': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastRoomMutedUsersResponseImage
     */
    'url_list': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseImage
     */
    'width': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponsePayGrade
 */
export interface WebcastRoomMutedUsersResponsePayGrade {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'deprecated20': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'deprecated22': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'deprecated23': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'deprecated24': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'deprecated25': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'deprecated26': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'grade_banner': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'grade_describe': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'grade_icon_list': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'level': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'next_name': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'next_privileges': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'score': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'screen_chat_type': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePayGrade
     */
    'upgrade_need_consume': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponsePrivilegeLogExtra
 */
export interface WebcastRoomMutedUsersResponsePrivilegeLogExtra {
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePrivilegeLogExtra
     */
    'data_version': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePrivilegeLogExtra
     */
    'end_time': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePrivilegeLogExtra
     */
    'level': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePrivilegeLogExtra
     */
    'privilege_id': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePrivilegeLogExtra
     */
    'privilege_order_id': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponsePrivilegeLogExtra
     */
    'privilege_version': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponsePrivilegeLogExtra
     */
    'start_time': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseUser
 */
export interface WebcastRoomMutedUsersResponseUser {
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_find_by_contacts': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_others_download_video': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_others_download_when_sharing_video': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_share_show_profile': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_show_in_gossip': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_show_my_action': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_strange_comment': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_unfollower_comment': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'allow_use_linkmic': boolean;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseImage}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'avatar_large': WebcastRoomMutedUsersResponseImage;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseImage}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'avatar_thumb': WebcastRoomMutedUsersResponseImage;
    /**
     * 
     * @type {Array<WebcastRoomMutedUsersResponseImage>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'badge_image_list': Array<WebcastRoomMutedUsersResponseImage>;
    /**
     * 
     * @type {Array<WebcastRoomMutedUsersResponseBadge>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'badge_list': Array<WebcastRoomMutedUsersResponseBadge>;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'bg_img_url': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'bio_description': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'block_status': number;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'border_list': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'comment_restrict': number;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'commerce_webcast_config_ids': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'constellation': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'create_time': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'disable_ichat': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'display_id': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'enable_ichat_img': number;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseEnigmaInfo}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'enigma_info': WebcastRoomMutedUsersResponseEnigmaInfo;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'exp': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'fan_ticket_count': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'fold_stranger_chat': boolean;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseFollowInfo}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'follow_info': WebcastRoomMutedUsersResponseFollowInfo;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'follow_status': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'ichat_restrict_type': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'id_str': string;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'is_anchor_marked': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'is_block': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'is_follower': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'is_following': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'is_subscribe': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'link_mic_stats': number;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'media_badge_image_list': Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'mint_type_label': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'modify_time': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'need_profile_guide': boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'new_real_time_icons': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'nickname': string;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponsePayGrade}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'pay_grade': WebcastRoomMutedUsersResponsePayGrade;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'pay_score': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'pay_scores': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'push_comment_status': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'push_digg': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'push_follow': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'push_friend_action': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'push_ichat': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'push_status': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'push_video_post': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'push_video_recommend': boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'real_time_icons': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'scm_label': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'sec_uid': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'secret': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'share_qrcode_uri': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'special_id': string;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'status': number;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'ticket_count': number;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'top_fans': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'top_vip_no': number;
    /**
     * 
     * @type {Array<any>}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'upcoming_event_list': Array<any>;
    /**
     * 
     * @type {WebcastRoomMutedUsersResponseUserAttr}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'user_attr': WebcastRoomMutedUsersResponseUserAttr;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'user_role': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'verified_content': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'verified_reason': string;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'with_car_management_permission': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'with_commerce_permission': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUser
     */
    'with_fusion_shop_entry': boolean;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersResponseUserAttr
 */
export interface WebcastRoomMutedUsersResponseUserAttr {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: number; }}
     * @memberof WebcastRoomMutedUsersResponseUserAttr
     */
    'admin_permissions': { [key: string]: number; };
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUserAttr
     */
    'has_voting_function': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUserAttr
     */
    'is_admin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUserAttr
     */
    'is_channel_admin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUserAttr
     */
    'is_muted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomMutedUsersResponseUserAttr
     */
    'is_super_admin': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomMutedUsersResponseUserAttr
     */
    'mute_duration': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomMutedUsersRouteOutput
 */
export interface WebcastRoomMutedUsersRouteOutput {
    /**
     * 
     * @type {WebcastRoomMutedUsersResponse}
     * @memberof WebcastRoomMutedUsersRouteOutput
     */
    'data': WebcastRoomMutedUsersResponse;
}
/**
 * 
 * @export
 * @interface WebcastRoomUnkickUserResponse
 */
export interface WebcastRoomUnkickUserResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastRoomUnkickUserResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {WebcastRoomUnkickUserResponseExtra}
     * @memberof WebcastRoomUnkickUserResponse
     */
    'extra': WebcastRoomUnkickUserResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomUnkickUserResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomUnkickUserResponseExtra
 */
export interface WebcastRoomUnkickUserResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomUnkickUserResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomUnkickUserRouteOutput
 */
export interface WebcastRoomUnkickUserRouteOutput {
    /**
     * 
     * @type {WebcastRoomUnkickUserResponse}
     * @memberof WebcastRoomUnkickUserRouteOutput
     */
    'data': WebcastRoomUnkickUserResponse;
}
/**
 * 
 * @export
 * @interface WebcastRoomUnmuteUserResponse
 */
export interface WebcastRoomUnmuteUserResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof WebcastRoomUnmuteUserResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {WebcastRoomUnmuteUserResponseExtra}
     * @memberof WebcastRoomUnmuteUserResponse
     */
    'extra': WebcastRoomUnmuteUserResponseExtra;
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomUnmuteUserResponse
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomUnmuteUserResponseExtra
 */
export interface WebcastRoomUnmuteUserResponseExtra {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomUnmuteUserResponseExtra
     */
    'now': number;
}
/**
 * 
 * @export
 * @interface WebcastRoomUnmuteUserRouteOutput
 */
export interface WebcastRoomUnmuteUserRouteOutput {
    /**
     * 
     * @type {WebcastRoomUnmuteUserResponse}
     * @memberof WebcastRoomUnmuteUserRouteOutput
     */
    'data': WebcastRoomUnmuteUserResponse;
}
/**
 * 
 * @export
 * @interface WebcastUserEarningsOutput
 */
export interface WebcastUserEarningsOutput {
    /**
     * 
     * @type {TikTokLiveUser}
     * @memberof WebcastUserEarningsOutput
     */
    'user': TikTokLiveUser;
    /**
     * 
     * @type {string}
     * @memberof WebcastUserEarningsOutput
     */
    'earnings_estimate_currency': WebcastUserEarningsOutputEarningsEstimateCurrencyEnum | null;
    /**
     * 
     * @type {number}
     * @memberof WebcastUserEarningsOutput
     */
    'earnings_estimate': number | null;
    /**
     * 
     * @type {number}
     * @memberof WebcastUserEarningsOutput
     */
    'diamonds': number | null;
    /**
     * 
     * @type {WebcastUserEarningsOutputPeriod}
     * @memberof WebcastUserEarningsOutput
     */
    'period': WebcastUserEarningsOutputPeriod;
    /**
     * 
     * @type {string}
     * @memberof WebcastUserEarningsOutput
     */
    'resets_at': string | null;
    /**
     * 
     * @type {number}
     * @memberof WebcastUserEarningsOutput
     */
    'resets_in': number | null;
}

export const WebcastUserEarningsOutputEarningsEstimateCurrencyEnum = {
    Usd: 'USD'
} as const;

export type WebcastUserEarningsOutputEarningsEstimateCurrencyEnum = typeof WebcastUserEarningsOutputEarningsEstimateCurrencyEnum[keyof typeof WebcastUserEarningsOutputEarningsEstimateCurrencyEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const WebcastUserEarningsOutputPeriod = {
    Daily: 'daily'
} as const;

export type WebcastUserEarningsOutputPeriod = typeof WebcastUserEarningsOutputPeriod[keyof typeof WebcastUserEarningsOutputPeriod];


/**
 * 
 * @export
 * @interface WebcastUserEarningsResponse
 */
export interface WebcastUserEarningsResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastUserEarningsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastUserEarningsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {WebcastUserEarningsOutput}
     * @memberof WebcastUserEarningsResponse
     */
    'response'?: WebcastUserEarningsOutput;
}
/**
 * 
 * @export
 * @interface WhirlCaptchaResponse
 */
export interface WhirlCaptchaResponse {
    /**
     * 
     * @type {WhirlResult}
     * @memberof WhirlCaptchaResponse
     */
    'response': WhirlResult | null;
    /**
     * 
     * @type {boolean}
     * @memberof WhirlCaptchaResponse
     */
    'cached': boolean;
    /**
     * 
     * @type {number}
     * @memberof WhirlCaptchaResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WhirlCaptchaResponse
     */
    'message'?: string;
}
/**
 * Captcha Server No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  The version of the OpenAPI document: 0.1   NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech). https://openapi-generator.tech Do not edit the class manually.
 * @export
 * @interface WhirlResult
 */
export interface WhirlResult {
    /**
     * 
     * @type {number}
     * @memberof WhirlResult
     */
    'time_ms': number;
    /**
     * 
     * @type {number}
     * @memberof WhirlResult
     */
    'angle': number;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccountSelf(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccountSelf(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.retrieveAccountSelf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf(options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAccountResponse> {
            return localVarFp.retrieveAccountSelf(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Retrieve an account from the Sign API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public retrieveAccountSelf(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).retrieveAccountSelf(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAgents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAgentHostsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAgents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.fetchAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents(options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAgentHostsResponse> {
            return localVarFp.fetchAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts(options?: RawAxiosRequestConfig): AxiosPromise<HostsResponse> {
            return localVarFp.getHosts(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public fetchAgents(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).fetchAgents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getHosts(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getHosts(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT: async (accountId: number, jWTCreateConfig: JWTCreateConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createJWT', 'accountId', accountId)
            // verify required parameter 'jWTCreateConfig' is not null or undefined
            assertParamExists('createJWT', 'jWTCreateConfig', jWTCreateConfig)
            const localVarPath = `/accounts/{account_id}/jwt/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jWTCreateConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (accountId: number, createKeyPayload: CreateKeyPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createKey', 'accountId', accountId)
            // verify required parameter 'createKeyPayload' is not null or undefined
            assertParamExists('createKey', 'createKeyPayload', createKeyPayload)
            const localVarPath = `/accounts/{account_id}/api_keys/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createKeyPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteKey', 'accountId', accountId)
            // verify required parameter 'deleteBy' is not null or undefined
            assertParamExists('deleteKey', 'deleteBy', deleteBy)
            // verify required parameter 'deleteParam' is not null or undefined
            assertParamExists('deleteKey', 'deleteParam', deleteParam)
            const localVarPath = `/accounts/{account_id}/api_keys/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (deleteBy !== undefined) {
                localVarQueryParameter['delete_by'] = deleteBy;
            }

            if (deleteParam !== undefined) {
                localVarQueryParameter['delete_param'] = deleteParam;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getKey', 'accountId', accountId)
            // verify required parameter 'retrieveParam' is not null or undefined
            assertParamExists('getKey', 'retrieveParam', retrieveParam)
            const localVarPath = `/accounts/{account_id}/api_keys/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (retrieveBy !== undefined) {
                localVarQueryParameter['retrieve_by'] = retrieveBy;
            }

            if (retrieveParam !== undefined) {
                localVarQueryParameter['retrieve_param'] = retrieveParam;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listKeys', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/api_keys/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateKey', 'accountId', accountId)
            // verify required parameter 'updateBy' is not null or undefined
            assertParamExists('updateKey', 'updateBy', updateBy)
            // verify required parameter 'updateParam' is not null or undefined
            assertParamExists('updateKey', 'updateParam', updateParam)
            // verify required parameter 'updateKeyPayload' is not null or undefined
            assertParamExists('updateKey', 'updateKeyPayload', updateKeyPayload)
            const localVarPath = `/accounts/{account_id}/api_keys/update`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (updateBy !== undefined) {
                localVarQueryParameter['update_by'] = updateBy;
            }

            if (updateParam !== undefined) {
                localVarQueryParameter['update_param'] = updateParam;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateKeyPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateJWTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJWT(accountId, jWTCreateConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.createJWT']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(accountId, createKeyPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.createKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(accountId, deleteBy, deleteParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.deleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(accountId, retrieveParam, retrieveBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeys(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeys(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.listKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): AxiosPromise<CreateJWTResponse> {
            return localVarFp.createJWT(accountId, jWTCreateConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateKeyResponse> {
            return localVarFp.createKey(accountId, createKeyPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteKeyResponse> {
            return localVarFp.deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveKeyResponse> {
            return localVarFp.getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListKeysResponse> {
            return localVarFp.listKeys(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig): AxiosPromise<UpdateKeyResponse> {
            return localVarFp.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createJWT(accountId, jWTCreateConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createKey(accountId, createKeyPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public listKeys(accountId: number, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).listKeys(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteKeyDeleteByEnum = {
    Value: 'value',
    Id: 'id'
} as const;
export type DeleteKeyDeleteByEnum = typeof DeleteKeyDeleteByEnum[keyof typeof DeleteKeyDeleteByEnum];
/**
 * @export
 */
export const GetKeyRetrieveByEnum = {
    Value: 'value',
    Id: 'id'
} as const;
export type GetKeyRetrieveByEnum = typeof GetKeyRetrieveByEnum[keyof typeof GetKeyRetrieveByEnum];
/**
 * @export
 */
export const UpdateKeyUpdateByEnum = {
    Value: 'value',
    Id: 'id'
} as const;
export type UpdateKeyUpdateByEnum = typeof UpdateKeyUpdateByEnum[keyof typeof UpdateKeyUpdateByEnum];


/**
 * TikTokCaptchasApi - axios parameter creator
 * @export
 */
export const TikTokCaptchasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the images upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
         * @param {string} prompt The prompt string provided by TikTok
         * @param {File} captchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeIconCaptcha: async (prompt: string, captchaImage: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prompt' is not null or undefined
            assertParamExists('completeIconCaptcha', 'prompt', prompt)
            // verify required parameter 'captchaImage' is not null or undefined
            assertParamExists('completeIconCaptcha', 'captchaImage', captchaImage)
            const localVarPath = `/tiktok/captchas/icons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }


            if (captchaImage !== undefined) { 
                localVarFormParams.append('captchaImage', captchaImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
         * @param {File} backgroundImage The uploaded background image file
         * @param {File} pieceImage The uploaded puzzle piece image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePuzzleCaptcha: async (backgroundImage: File, pieceImage: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backgroundImage' is not null or undefined
            assertParamExists('completePuzzleCaptcha', 'backgroundImage', backgroundImage)
            // verify required parameter 'pieceImage' is not null or undefined
            assertParamExists('completePuzzleCaptcha', 'pieceImage', pieceImage)
            const localVarPath = `/tiktok/captchas/puzzle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


            if (backgroundImage !== undefined) { 
                localVarFormParams.append('backgroundImage', backgroundImage as any);
            }
    
            if (pieceImage !== undefined) { 
                localVarFormParams.append('pieceImage', pieceImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
         * @param {File} shapesCaptchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeShapesCaptcha: async (shapesCaptchaImage: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shapesCaptchaImage' is not null or undefined
            assertParamExists('completeShapesCaptcha', 'shapesCaptchaImage', shapesCaptchaImage)
            const localVarPath = `/tiktok/captchas/shapes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


            if (shapesCaptchaImage !== undefined) { 
                localVarFormParams.append('shapesCaptchaImage', shapesCaptchaImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
         * @param {File} outerImage The outer image file
         * @param {File} innerImage The inner image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWhirlCaptcha: async (outerImage: File, innerImage: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outerImage' is not null or undefined
            assertParamExists('completeWhirlCaptcha', 'outerImage', outerImage)
            // verify required parameter 'innerImage' is not null or undefined
            assertParamExists('completeWhirlCaptcha', 'innerImage', innerImage)
            const localVarPath = `/tiktok/captchas/whirl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


            if (outerImage !== undefined) { 
                localVarFormParams.append('outerImage', outerImage as any);
            }
    
            if (innerImage !== undefined) { 
                localVarFormParams.append('innerImage', innerImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rate limits for the provided API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaptchaCredits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tiktok/captchas/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokCaptchasApi - functional programming interface
 * @export
 */
export const TikTokCaptchasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokCaptchasApiAxiosParamCreator(configuration)
    return {
        /**
         *  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the images upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
         * @param {string} prompt The prompt string provided by TikTok
         * @param {File} captchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeIconCaptcha(prompt: string, captchaImage: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IconCaptchaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeIconCaptcha(prompt, captchaImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokCaptchasApi.completeIconCaptcha']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
         * @param {File} backgroundImage The uploaded background image file
         * @param {File} pieceImage The uploaded puzzle piece image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completePuzzleCaptcha(backgroundImage: File, pieceImage: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PuzzleCaptchaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completePuzzleCaptcha(backgroundImage, pieceImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokCaptchasApi.completePuzzleCaptcha']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
         * @param {File} shapesCaptchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeShapesCaptcha(shapesCaptchaImage: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShapesCaptchaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeShapesCaptcha(shapesCaptchaImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokCaptchasApi.completeShapesCaptcha']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
         * @param {File} outerImage The outer image file
         * @param {File} innerImage The inner image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeWhirlCaptcha(outerImage: File, innerImage: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WhirlCaptchaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWhirlCaptcha(outerImage, innerImage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokCaptchasApi.completeWhirlCaptcha']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaptchaCredits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaptchaCreditsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaptchaCredits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokCaptchasApi.retrieveCaptchaCredits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokCaptchasApi - factory interface
 * @export
 */
export const TikTokCaptchasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokCaptchasApiFp(configuration)
    return {
        /**
         *  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the images upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
         * @param {string} prompt The prompt string provided by TikTok
         * @param {File} captchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeIconCaptcha(prompt: string, captchaImage: File, options?: RawAxiosRequestConfig): AxiosPromise<IconCaptchaResponse> {
            return localVarFp.completeIconCaptcha(prompt, captchaImage, options).then((request) => request(axios, basePath));
        },
        /**
         * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
         * @param {File} backgroundImage The uploaded background image file
         * @param {File} pieceImage The uploaded puzzle piece image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completePuzzleCaptcha(backgroundImage: File, pieceImage: File, options?: RawAxiosRequestConfig): AxiosPromise<PuzzleCaptchaResponse> {
            return localVarFp.completePuzzleCaptcha(backgroundImage, pieceImage, options).then((request) => request(axios, basePath));
        },
        /**
         * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
         * @param {File} shapesCaptchaImage The uploaded image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeShapesCaptcha(shapesCaptchaImage: File, options?: RawAxiosRequestConfig): AxiosPromise<ShapesCaptchaResponse> {
            return localVarFp.completeShapesCaptcha(shapesCaptchaImage, options).then((request) => request(axios, basePath));
        },
        /**
         * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
         * @param {File} outerImage The outer image file
         * @param {File} innerImage The inner image file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWhirlCaptcha(outerImage: File, innerImage: File, options?: RawAxiosRequestConfig): AxiosPromise<WhirlCaptchaResponse> {
            return localVarFp.completeWhirlCaptcha(outerImage, innerImage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaptchaCredits(options?: RawAxiosRequestConfig): AxiosPromise<CaptchaCreditsResponse> {
            return localVarFp.retrieveCaptchaCredits(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokCaptchasApi - object-oriented interface
 * @export
 * @class TikTokCaptchasApi
 * @extends {BaseAPI}
 */
export class TikTokCaptchasApi extends BaseAPI {
    /**
     *  The icons captcha requires just one image & a prompt string.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/icon.png\" alt=\"Icons Captcha Example\" width=\"480\" />  ## Usage  The `prompt` is the text prompt provided by TikTok. The Icon captcha solution is provided as a list of points, where each point marks a location on the image that needs to be clicked. These points are expressed as ratios relative to the image\'s width and height. A point of (0.0, 0.0) corresponds to the images upper-left corner, while (1.0, 1.0) represents the lower-right corner. For reference, (0.5, 0.5) sits at the exact center.  The captcha image selector is `.captcha-verify-image`
     * @param {string} prompt The prompt string provided by TikTok
     * @param {File} captchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokCaptchasApi
     */
    public completeIconCaptcha(prompt: string, captchaImage: File, options?: RawAxiosRequestConfig) {
        return TikTokCaptchasApiFp(this.configuration).completeIconCaptcha(prompt, captchaImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The puzzle captcha requires two images  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/puzzle.png\" alt=\"Puzzle Piece Example\" width=\"480\" />  ## Usage  The solution to the puzzle captcha is the distance to move the slider to fit the puzzle piece into the background.  The `backgroundImage` is the full background image with the missing piece. The `pieceImage` is the small puzzle piece that needs to be fit into the background.  The captcha image selectors are: - Background: `.captcha-verify-image` - Piece: `#captcha-verify-image ~ div.cap-absolute > img`  The solution is the `x` proportion (0-1) of the width of the background image where the piece fits. It is 1:1 with the slider distance proportion.
     * @param {File} backgroundImage The uploaded background image file
     * @param {File} pieceImage The uploaded puzzle piece image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokCaptchasApi
     */
    public completePuzzleCaptcha(backgroundImage: File, pieceImage: File, options?: RawAxiosRequestConfig) {
        return TikTokCaptchasApiFp(this.configuration).completePuzzleCaptcha(backgroundImage, pieceImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The shapes captcha requires just one image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/threed.png\" alt=\"Shapes Captcha Example\" width=\"480\" />  ## Usage  The solution to the shapes captcha are two points that need to be clicked. To use it in the GUI, convert the proportions to pixel values based on the image size.  The `points` are returned as `x` and `y` proportions (0-1) of the width and height of the source image. The captcha image selector is `.captcha-verify-image`
     * @param {File} shapesCaptchaImage The uploaded image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokCaptchasApi
     */
    public completeShapesCaptcha(shapesCaptchaImage: File, options?: RawAxiosRequestConfig) {
        return TikTokCaptchasApiFp(this.configuration).completeShapesCaptcha(shapesCaptchaImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The whirl captcha requires two images: the outer image and the inner image.  ## Example Image <img src=\"https://www.eulerstream.com/_static/captchas/rotate.png\" alt=\"Whirl Captcha Example\" width=\"480\" />  ## Usage  The solution to the whirl captcha is an angle from 0-360. To use it in the GUI, it must be converted to a slider distance:  `px = ((sidebar_length - icon_length) * angle) / 360`  - `sidebar_length` is the width of `.captcha_verify_slide--slidebar` - `icon_length` is the width of `.secsdk-captcha-drag-icon`
     * @param {File} outerImage The outer image file
     * @param {File} innerImage The inner image file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokCaptchasApi
     */
    public completeWhirlCaptcha(outerImage: File, innerImage: File, options?: RawAxiosRequestConfig) {
        return TikTokCaptchasApiFp(this.configuration).completeWhirlCaptcha(outerImage, innerImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the rate limits for the provided API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokCaptchasApi
     */
    public retrieveCaptchaCredits(options?: RawAxiosRequestConfig) {
        return TikTokCaptchasApiFp(this.configuration).retrieveCaptchaCredits(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TikTokGeneralApi - axios parameter creator
 * @export
 */
export const TikTokGeneralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Exchange an authorization code or refresh token for access tokens.  For authorization_code grant: - code: The authorization code from /oauth/complete - redirect_uri: Must match the original redirect_uri  For refresh_token grant: - refresh_token: A valid refresh token
         * @param {ExchangeTokenRequest} exchangeTokenRequest Token request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeToken: async (exchangeTokenRequest: ExchangeTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeTokenRequest' is not null or undefined
            assertParamExists('exchangeToken', 'exchangeTokenRequest', exchangeTokenRequest)
            const localVarPath = `/tiktok/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exchangeTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an access token or refresh token (RFC 7009). This endpoint always returns success for valid client credentials, even if the token was already revoked or invalid.
         * @param {RevokeRequestBody} revokeRequestBody Revoke request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: async (revokeRequestBody: RevokeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'revokeRequestBody' is not null or undefined
            assertParamExists('revokeToken', 'revokeRequestBody', revokeRequestBody)
            const localVarPath = `/tiktok/oauth/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokGeneralApi - functional programming interface
 * @export
 */
export const TikTokGeneralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokGeneralApiAxiosParamCreator(configuration)
    return {
        /**
         * Exchange an authorization code or refresh token for access tokens.  For authorization_code grant: - code: The authorization code from /oauth/complete - redirect_uri: Must match the original redirect_uri  For refresh_token grant: - refresh_token: A valid refresh token
         * @param {ExchangeTokenRequest} exchangeTokenRequest Token request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangeToken(exchangeTokenRequest: ExchangeTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangeToken(exchangeTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokGeneralApi.exchangeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke an access token or refresh token (RFC 7009). This endpoint always returns success for valid client credentials, even if the token was already revoked or invalid.
         * @param {RevokeRequestBody} revokeRequestBody Revoke request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeToken(revokeRequestBody: RevokeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthRevokeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeToken(revokeRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokGeneralApi.revokeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokGeneralApi - factory interface
 * @export
 */
export const TikTokGeneralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokGeneralApiFp(configuration)
    return {
        /**
         * Exchange an authorization code or refresh token for access tokens.  For authorization_code grant: - code: The authorization code from /oauth/complete - redirect_uri: Must match the original redirect_uri  For refresh_token grant: - refresh_token: A valid refresh token
         * @param {ExchangeTokenRequest} exchangeTokenRequest Token request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeToken(exchangeTokenRequest: ExchangeTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<OAuthTokenResponse> {
            return localVarFp.exchangeToken(exchangeTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an access token or refresh token (RFC 7009). This endpoint always returns success for valid client credentials, even if the token was already revoked or invalid.
         * @param {RevokeRequestBody} revokeRequestBody Revoke request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(revokeRequestBody: RevokeRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<OAuthRevokeResponse> {
            return localVarFp.revokeToken(revokeRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokGeneralApi - object-oriented interface
 * @export
 * @class TikTokGeneralApi
 * @extends {BaseAPI}
 */
export class TikTokGeneralApi extends BaseAPI {
    /**
     * Exchange an authorization code or refresh token for access tokens.  For authorization_code grant: - code: The authorization code from /oauth/complete - redirect_uri: Must match the original redirect_uri  For refresh_token grant: - refresh_token: A valid refresh token
     * @param {ExchangeTokenRequest} exchangeTokenRequest Token request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokGeneralApi
     */
    public exchangeToken(exchangeTokenRequest: ExchangeTokenRequest, options?: RawAxiosRequestConfig) {
        return TikTokGeneralApiFp(this.configuration).exchangeToken(exchangeTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an access token or refresh token (RFC 7009). This endpoint always returns success for valid client credentials, even if the token was already revoked or invalid.
     * @param {RevokeRequestBody} revokeRequestBody Revoke request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokGeneralApi
     */
    public revokeToken(revokeRequestBody: RevokeRequestBody, options?: RawAxiosRequestConfig) {
        return TikTokGeneralApiFp(this.configuration).revokeToken(revokeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TikTokLIVEApi - axios parameter creator
 * @export
 */
export const TikTokLIVEApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.  **Authentication (Optional):** Anonymous access is supported. For authenticated requests, provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {SoaxProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL: async (client?: string, roomId?: string, uniqueId?: string, cursor?: string, userAgent?: string, clientEnter?: boolean, country?: SoaxProxyRegion, platform?: WebcastFetchPlatform, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webcast/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (userAgent !== undefined) {
                localVarQueryParameter['user_agent'] = userAgent;
            }

            if (clientEnter !== undefined) {
                localVarQueryParameter['client_enter'] = clientEnter;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webcast/rate_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {string} [webcastLanguage] Webcast language for locale-based fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGiftInfo: async (roomId: string, webcastLanguage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('retrieveGiftInfo', 'roomId', roomId)
            const localVarPath = `/webcast/gift_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (webcastLanguage !== undefined) {
                localVarQueryParameter['webcast_language'] = webcastLanguage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of available hashtags for TikTok LIVE streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveHashtagList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webcast/hashtag_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Business Plan - Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover: async (uniqueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomCover', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_cover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Business Plan - Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId: async (uniqueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomId', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Business Plan - Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo: async (uniqueId: string, streamType?: StreamType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomVideo', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }

            if (streamType !== undefined) {
                localVarQueryParameter['streamType'] = streamType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Retrieve TikTok LIVE rankings for a specific region.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastRankings: async (region: OxyLabsProxyRegion, rankType: RetrieveWebcastRankingsRankTypeEnum, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('retrieveWebcastRankings', 'region', region)
            // verify required parameter 'rankType' is not null or undefined
            assertParamExists('retrieveWebcastRankings', 'rankType', rankType)
            const localVarPath = `/webcast/rankings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (rankType !== undefined) {
                localVarQueryParameter['rank_type'] = rankType;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignTikTokUrlBody} signTikTokUrlBody 
         * @param {string} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl: async (signTikTokUrlBody: SignTikTokUrlBody, client?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signTikTokUrlBody' is not null or undefined
            assertParamExists('signWebcastUrl', 'signTikTokUrlBody', signTikTokUrlBody)
            const localVarPath = `/webcast/sign_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signTikTokUrlBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokLIVEApi - functional programming interface
 * @export
 */
export const TikTokLIVEApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokLIVEApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.  **Authentication (Optional):** Anonymous access is supported. For authenticated requests, provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {SoaxProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, userAgent?: string, clientEnter?: boolean, country?: SoaxProxyRegion, platform?: WebcastFetchPlatform, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchWebcastURL(client, roomId, uniqueId, cursor, userAgent, clientEnter, country, platform, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.fetchWebcastURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRateLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.getRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {string} [webcastLanguage] Webcast language for locale-based fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGiftInfo(roomId: string, webcastLanguage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastGiftInfoRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGiftInfo(roomId, webcastLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveGiftInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of available hashtags for TikTok LIVE streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveHashtagList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashtagListAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveHashtagList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveHashtagList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Business Plan - Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JSONResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomCover(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveRoomCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Business Plan - Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomIdRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomId(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveRoomId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Business Plan - Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JSONResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomVideo(uniqueId, streamType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveRoomVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Retrieve TikTok LIVE rankings for a specific region.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveWebcastRankings(region: OxyLabsProxyRegion, rankType: RetrieveWebcastRankingsRankTypeEnum, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRegionRankingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveWebcastRankings(region, rankType, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveWebcastRankings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignTikTokUrlBody} signTikTokUrlBody 
         * @param {string} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignWebcastUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signWebcastUrl(signTikTokUrlBody, client, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.signWebcastUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokLIVEApi - factory interface
 * @export
 */
export const TikTokLIVEApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokLIVEApiFp(configuration)
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.  **Authentication (Optional):** Anonymous access is supported. For authenticated requests, provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {SoaxProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, userAgent?: string, clientEnter?: boolean, country?: SoaxProxyRegion, platform?: WebcastFetchPlatform, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.fetchWebcastURL(client, roomId, uniqueId, cursor, userAgent, clientEnter, country, platform, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits(options?: RawAxiosRequestConfig): AxiosPromise<GetRateLimits> {
            return localVarFp.getRateLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {string} [webcastLanguage] Webcast language for locale-based fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGiftInfo(roomId: string, webcastLanguage?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastGiftInfoRouteResponse> {
            return localVarFp.retrieveGiftInfo(roomId, webcastLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of available hashtags for TikTok LIVE streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveHashtagList(options?: RawAxiosRequestConfig): AxiosPromise<HashtagListAPIResponse> {
            return localVarFp.retrieveHashtagList(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Business Plan - Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<JSONResponse> {
            return localVarFp.retrieveRoomCover(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Business Plan - Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomIdRouteResponse> {
            return localVarFp.retrieveRoomId(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Business Plan - Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): AxiosPromise<JSONResponse> {
            return localVarFp.retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Retrieve TikTok LIVE rankings for a specific region.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastRankings(region: OxyLabsProxyRegion, rankType: RetrieveWebcastRankingsRankTypeEnum, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRegionRankingsResponse> {
            return localVarFp.retrieveWebcastRankings(region, rankType, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignTikTokUrlBody} signTikTokUrlBody 
         * @param {string} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig): AxiosPromise<SignWebcastUrl200Response> {
            return localVarFp.signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokLIVEApi - object-oriented interface
 * @export
 * @class TikTokLIVEApi
 * @extends {BaseAPI}
 */
export class TikTokLIVEApi extends BaseAPI {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.  **Authentication (Optional):** Anonymous access is supported. For authenticated requests, provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} [client] The client library identifier. Used for metrics.
     * @param {string} [roomId] The room ID to fetch the Webcast URL for.
     * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
     * @param {string} [cursor] Starting cursor for the webcast connection, if any
     * @param {string} [userAgent] Override the user agent used for signing and fetching
     * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
     * @param {SoaxProxyRegion} [country] Country code to make the request from.
     * @param {WebcastFetchPlatform} [platform] Platform to connect with
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
     * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, userAgent?: string, clientEnter?: boolean, country?: SoaxProxyRegion, platform?: WebcastFetchPlatform, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).fetchWebcastURL(client, roomId, uniqueId, cursor, userAgent, clientEnter, country, platform, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public getRateLimits(options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).getRateLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve TikTok Live Room Gift List
     * @param {string} roomId The room ID of the TikTok LIVE session
     * @param {string} [webcastLanguage] Webcast language for locale-based fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveGiftInfo(roomId: string, webcastLanguage?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveGiftInfo(roomId, webcastLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Retrieve the list of available hashtags for TikTok LIVE streams.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveHashtagList(options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveHashtagList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Business Plan - Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveRoomCover(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Business Plan - Fetch Room ID for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveRoomId(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Business Plan - Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Retrieve TikTok LIVE rankings for a specific region.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {RetrieveWebcastRankingsRankTypeEnum} rankType The type of ranking to fetch. See documentation for more details.
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
     * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveWebcastRankings(region: OxyLabsProxyRegion, rankType: RetrieveWebcastRankingsRankTypeEnum, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveWebcastRankings(region, rankType, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignTikTokUrlBody} signTikTokUrlBody 
     * @param {string} [client] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RetrieveWebcastRankingsRankTypeEnum = {
    FansTeamRank: 'FANS_TEAM_RANK',
    DailyRank: 'DAILY_RANK'
} as const;
export type RetrieveWebcastRankingsRankTypeEnum = typeof RetrieveWebcastRankingsRankTypeEnum[keyof typeof RetrieveWebcastRankingsRankTypeEnum];


/**
 * TikTokLIVEAlertTargetsApi - axios parameter creator
 * @export
 */
export const TikTokLIVEAlertTargetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget: async (accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('createAlertTarget', 'alertId', alertId)
            // verify required parameter 'createAlertTargetPayload' is not null or undefined
            assertParamExists('createAlertTarget', 'createAlertTargetPayload', createAlertTargetPayload)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertTargetPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget: async (accountId: number, alertId: number, targetId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'alertId', alertId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'targetId', targetId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets: async (accountId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAlertTargets', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('listAlertTargets', 'alertId', alertId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget: async (accountId: number, alertId: number, targetId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('testAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('testAlertTarget', 'alertId', alertId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('testAlertTarget', 'targetId', targetId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/test`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokLIVEAlertTargetsApi - functional programming interface
 * @export
 */
export const TikTokLIVEAlertTargetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokLIVEAlertTargetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertTarget(accountId, alertId, createAlertTargetPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEAlertTargetsApi.createAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEAlertTargetsApi.deleteAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAlertTargetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertTargets(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEAlertTargetsApi.listAlertTargets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEAlertTargetsApi.testAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokLIVEAlertTargetsApi - factory interface
 * @export
 */
export const TikTokLIVEAlertTargetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokLIVEAlertTargetsApiFp(configuration)
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateAlertTargetResponse> {
            return localVarFp.createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAlertTargetResponse> {
            return localVarFp.deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAlertTargetsResponse> {
            return localVarFp.listAlertTargets(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<TestAlertTargetResponse> {
            return localVarFp.testAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokLIVEAlertTargetsApi - object-oriented interface
 * @export
 * @class TikTokLIVEAlertTargetsApi
 * @extends {BaseAPI}
 */
export class TikTokLIVEAlertTargetsApi extends BaseAPI {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEAlertTargetsApi
     */
    public createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig) {
        return TikTokLIVEAlertTargetsApiFp(this.configuration).createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEAlertTargetsApi
     */
    public deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) {
        return TikTokLIVEAlertTargetsApiFp(this.configuration).deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEAlertTargetsApi
     */
    public listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return TikTokLIVEAlertTargetsApiFp(this.configuration).listAlertTargets(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEAlertTargetsApi
     */
    public testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) {
        return TikTokLIVEAlertTargetsApiFp(this.configuration).testAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TikTokLIVEAlertsApi - axios parameter creator
 * @export
 */
export const TikTokLIVEAlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (accountId: number, createAlertRequest: CreateAlertRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAlert', 'accountId', accountId)
            // verify required parameter 'createAlertRequest' is not null or undefined
            assertParamExists('createAlert', 'createAlertRequest', createAlertRequest)
            const localVarPath = `/accounts/{account_id}/alerts/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (accountId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAlert', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlert', 'alertId', alertId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (accountId: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAlerts', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/alerts/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert: async (accountId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('retrieveAlert', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('retrieveAlert', 'alertId', alertId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokLIVEAlertsApi - functional programming interface
 * @export
 */
export const TikTokLIVEAlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokLIVEAlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(accountId, createAlertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEAlertsApi.createAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEAlertsApi.deleteAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAlertsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(accountId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEAlertsApi.listAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEAlertsApi.retrieveAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokLIVEAlertsApi - factory interface
 * @export
 */
export const TikTokLIVEAlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokLIVEAlertsApiFp(configuration)
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAlertResponse> {
            return localVarFp.createAlert(accountId, createAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAlertResponse> {
            return localVarFp.deleteAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAlertsResponse> {
            return localVarFp.listAlerts(accountId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAlertResponse> {
            return localVarFp.retrieveAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokLIVEAlertsApi - object-oriented interface
 * @export
 * @class TikTokLIVEAlertsApi
 * @extends {BaseAPI}
 */
export class TikTokLIVEAlertsApi extends BaseAPI {
    /**
     * Create a creator alert. These Alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEAlertsApi
     */
    public createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig) {
        return TikTokLIVEAlertsApiFp(this.configuration).createAlert(accountId, createAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEAlertsApi
     */
    public deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return TikTokLIVEAlertsApiFp(this.configuration).deleteAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEAlertsApi
     */
    public listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig) {
        return TikTokLIVEAlertsApiFp(this.configuration).listAlerts(accountId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEAlertsApi
     */
    public retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return TikTokLIVEAlertsApiFp(this.configuration).retrieveAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TikTokLIVEModerationApi - axios parameter creator
 * @export
 */
export const TikTokLIVEModerationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires Premium Routes Addon - Add a moderator in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} toUserId The user ID to add as moderator
         * @param {string} anchorId The streamer\&#39;s user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoomModerator: async (toUserId: string, anchorId: string, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toUserId' is not null or undefined
            assertParamExists('addRoomModerator', 'toUserId', toUserId)
            // verify required parameter 'anchorId' is not null or undefined
            assertParamExists('addRoomModerator', 'anchorId', anchorId)
            const localVarPath = `/webcast/moderation/moderators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (toUserId !== undefined) {
                localVarQueryParameter['to_user_id'] = toUserId;
            }

            if (anchorId !== undefined) {
                localVarQueryParameter['anchor_id'] = anchorId;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Kick a user from a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} tiktokUserId The numeric user ID for the individual to kick
         * @param {string} [commentMsgId] Optional comment message ID that triggered the kick
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickRoomUser: async (roomId: string, tiktokUserId: string, commentMsgId?: string, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('kickRoomUser', 'roomId', roomId)
            // verify required parameter 'tiktokUserId' is not null or undefined
            assertParamExists('kickRoomUser', 'tiktokUserId', tiktokUserId)
            const localVarPath = `/webcast/moderation/bans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (tiktokUserId !== undefined) {
                localVarQueryParameter['tiktok_user_id'] = tiktokUserId;
            }

            if (commentMsgId !== undefined) {
                localVarQueryParameter['comment_msg_id'] = commentMsgId;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Mute a user in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} userId The user ID to mute
         * @param {MuteDuration} [duration] Mute duration in seconds (-1 &#x3D; permanent, 5, 30, 60, 300)
         * @param {number} [commentMsgId] Optional comment message ID that triggered the mute
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        muteRoomUser: async (roomId: string, userId: string, duration?: MuteDuration, commentMsgId?: number, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('muteRoomUser', 'roomId', roomId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('muteRoomUser', 'userId', userId)
            const localVarPath = `/webcast/moderation/mutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (commentMsgId !== undefined) {
                localVarQueryParameter['comment_msg_id'] = commentMsgId;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Remove a moderator from a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} toUserId The user ID to remove as moderator
         * @param {string} anchorId The streamer\&#39;s user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRoomModerator: async (toUserId: string, anchorId: string, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toUserId' is not null or undefined
            assertParamExists('removeRoomModerator', 'toUserId', toUserId)
            // verify required parameter 'anchorId' is not null or undefined
            assertParamExists('removeRoomModerator', 'anchorId', anchorId)
            const localVarPath = `/webcast/moderation/moderators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (toUserId !== undefined) {
                localVarQueryParameter['to_user_id'] = toUserId;
            }

            if (anchorId !== undefined) {
                localVarQueryParameter['anchor_id'] = anchorId;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of banned users in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {number} [page] Page number for pagination (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomBannedUsers: async (roomId: string, page?: number, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('retrieveRoomBannedUsers', 'roomId', roomId)
            const localVarPath = `/webcast/moderation/bans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of moderators in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} anchorId The streamer\&#39;s numeric user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomModerators: async (anchorId: string, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'anchorId' is not null or undefined
            assertParamExists('retrieveRoomModerators', 'anchorId', anchorId)
            const localVarPath = `/webcast/moderation/moderators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (anchorId !== undefined) {
                localVarQueryParameter['anchor_id'] = anchorId;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of muted users in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {number} [page] Page number for pagination (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomMutedUsers: async (roomId: string, page?: number, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('retrieveRoomMutedUsers', 'roomId', roomId)
            const localVarPath = `/webcast/moderation/mutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Toggle comments on/off in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {boolean} enabled Whether comments should be enabled (true) or disabled (false)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleRoomComments: async (roomId: string, enabled: boolean, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('toggleRoomComments', 'roomId', roomId)
            // verify required parameter 'enabled' is not null or undefined
            assertParamExists('toggleRoomComments', 'enabled', enabled)
            const localVarPath = `/webcast/moderation/toggle_comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Unkick a user from a livestream room (allow them back).  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} tiktokUserId The numeric user ID of the person to unkick
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanRoomUser: async (roomId: string, tiktokUserId: string, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('unbanRoomUser', 'roomId', roomId)
            // verify required parameter 'tiktokUserId' is not null or undefined
            assertParamExists('unbanRoomUser', 'tiktokUserId', tiktokUserId)
            const localVarPath = `/webcast/moderation/bans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (tiktokUserId !== undefined) {
                localVarQueryParameter['tiktok_user_id'] = tiktokUserId;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Unmute a user in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} userId The user ID to unmute
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmuteRoomUser: async (roomId: string, userId: string, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('unmuteRoomUser', 'roomId', roomId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unmuteRoomUser', 'userId', userId)
            const localVarPath = `/webcast/moderation/mutes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokLIVEModerationApi - functional programming interface
 * @export
 */
export const TikTokLIVEModerationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokLIVEModerationApiAxiosParamCreator(configuration)
    return {
        /**
         * Requires Premium Routes Addon - Add a moderator in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} toUserId The user ID to add as moderator
         * @param {string} anchorId The streamer\&#39;s user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRoomModerator(toUserId: string, anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomAdminUpdateAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRoomModerator(toUserId, anchorId, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.addRoomModerator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Kick a user from a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} tiktokUserId The numeric user ID for the individual to kick
         * @param {string} [commentMsgId] Optional comment message ID that triggered the kick
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kickRoomUser(roomId: string, tiktokUserId: string, commentMsgId?: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomKickUserAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kickRoomUser(roomId, tiktokUserId, commentMsgId, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.kickRoomUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Mute a user in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} userId The user ID to mute
         * @param {MuteDuration} [duration] Mute duration in seconds (-1 &#x3D; permanent, 5, 30, 60, 300)
         * @param {number} [commentMsgId] Optional comment message ID that triggered the mute
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async muteRoomUser(roomId: string, userId: string, duration?: MuteDuration, commentMsgId?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomMuteUserAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.muteRoomUser(roomId, userId, duration, commentMsgId, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.muteRoomUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Remove a moderator from a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} toUserId The user ID to remove as moderator
         * @param {string} anchorId The streamer\&#39;s user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRoomModerator(toUserId: string, anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomAdminUpdateAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRoomModerator(toUserId, anchorId, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.removeRoomModerator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of banned users in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {number} [page] Page number for pagination (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomBannedUsers(roomId: string, page?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomKickedUsersAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomBannedUsers(roomId, page, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.retrieveRoomBannedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of moderators in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} anchorId The streamer\&#39;s numeric user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomModerators(anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomModeratorsAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomModerators(anchorId, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.retrieveRoomModerators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of muted users in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {number} [page] Page number for pagination (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomMutedUsers(roomId: string, page?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomMutedUsersAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomMutedUsers(roomId, page, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.retrieveRoomMutedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Toggle comments on/off in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {boolean} enabled Whether comments should be enabled (true) or disabled (false)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleRoomComments(roomId: string, enabled: boolean, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomCommentsToggleAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleRoomComments(roomId, enabled, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.toggleRoomComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Unkick a user from a livestream room (allow them back).  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} tiktokUserId The numeric user ID of the person to unkick
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbanRoomUser(roomId: string, tiktokUserId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomUnkickUserAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbanRoomUser(roomId, tiktokUserId, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.unbanRoomUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Unmute a user in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} userId The user ID to unmute
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unmuteRoomUser(roomId: string, userId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomUnmuteUserAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unmuteRoomUser(roomId, userId, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEModerationApi.unmuteRoomUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokLIVEModerationApi - factory interface
 * @export
 */
export const TikTokLIVEModerationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokLIVEModerationApiFp(configuration)
    return {
        /**
         * Requires Premium Routes Addon - Add a moderator in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} toUserId The user ID to add as moderator
         * @param {string} anchorId The streamer\&#39;s user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoomModerator(toUserId: string, anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomAdminUpdateAPIResponse> {
            return localVarFp.addRoomModerator(toUserId, anchorId, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Kick a user from a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} tiktokUserId The numeric user ID for the individual to kick
         * @param {string} [commentMsgId] Optional comment message ID that triggered the kick
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickRoomUser(roomId: string, tiktokUserId: string, commentMsgId?: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomKickUserAPIResponse> {
            return localVarFp.kickRoomUser(roomId, tiktokUserId, commentMsgId, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Mute a user in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} userId The user ID to mute
         * @param {MuteDuration} [duration] Mute duration in seconds (-1 &#x3D; permanent, 5, 30, 60, 300)
         * @param {number} [commentMsgId] Optional comment message ID that triggered the mute
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        muteRoomUser(roomId: string, userId: string, duration?: MuteDuration, commentMsgId?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomMuteUserAPIResponse> {
            return localVarFp.muteRoomUser(roomId, userId, duration, commentMsgId, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Remove a moderator from a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} toUserId The user ID to remove as moderator
         * @param {string} anchorId The streamer\&#39;s user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRoomModerator(toUserId: string, anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomAdminUpdateAPIResponse> {
            return localVarFp.removeRoomModerator(toUserId, anchorId, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of banned users in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {number} [page] Page number for pagination (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomBannedUsers(roomId: string, page?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomKickedUsersAPIResponse> {
            return localVarFp.retrieveRoomBannedUsers(roomId, page, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of moderators in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} anchorId The streamer\&#39;s numeric user ID
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomModerators(anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomModeratorsAPIResponse> {
            return localVarFp.retrieveRoomModerators(anchorId, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of muted users in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {number} [page] Page number for pagination (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomMutedUsers(roomId: string, page?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomMutedUsersAPIResponse> {
            return localVarFp.retrieveRoomMutedUsers(roomId, page, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Toggle comments on/off in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {boolean} enabled Whether comments should be enabled (true) or disabled (false)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleRoomComments(roomId: string, enabled: boolean, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomCommentsToggleAPIResponse> {
            return localVarFp.toggleRoomComments(roomId, enabled, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Unkick a user from a livestream room (allow them back).  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} tiktokUserId The numeric user ID of the person to unkick
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanRoomUser(roomId: string, tiktokUserId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomUnkickUserAPIResponse> {
            return localVarFp.unbanRoomUser(roomId, tiktokUserId, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Unmute a user in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream
         * @param {string} userId The user ID to unmute
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmuteRoomUser(roomId: string, userId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomUnmuteUserAPIResponse> {
            return localVarFp.unmuteRoomUser(roomId, userId, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokLIVEModerationApi - object-oriented interface
 * @export
 * @class TikTokLIVEModerationApi
 * @extends {BaseAPI}
 */
export class TikTokLIVEModerationApi extends BaseAPI {
    /**
     * Requires Premium Routes Addon - Add a moderator in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} toUserId The user ID to add as moderator
     * @param {string} anchorId The streamer\&#39;s user ID
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public addRoomModerator(toUserId: string, anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).addRoomModerator(toUserId, anchorId, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Kick a user from a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} roomId The room ID of the livestream
     * @param {string} tiktokUserId The numeric user ID for the individual to kick
     * @param {string} [commentMsgId] Optional comment message ID that triggered the kick
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public kickRoomUser(roomId: string, tiktokUserId: string, commentMsgId?: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).kickRoomUser(roomId, tiktokUserId, commentMsgId, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Mute a user in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} roomId The room ID of the livestream
     * @param {string} userId The user ID to mute
     * @param {MuteDuration} [duration] Mute duration in seconds (-1 &#x3D; permanent, 5, 30, 60, 300)
     * @param {number} [commentMsgId] Optional comment message ID that triggered the mute
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public muteRoomUser(roomId: string, userId: string, duration?: MuteDuration, commentMsgId?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).muteRoomUser(roomId, userId, duration, commentMsgId, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Remove a moderator from a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} toUserId The user ID to remove as moderator
     * @param {string} anchorId The streamer\&#39;s user ID
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public removeRoomModerator(toUserId: string, anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).removeRoomModerator(toUserId, anchorId, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Retrieve the list of banned users in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} roomId The room ID of the livestream
     * @param {number} [page] Page number for pagination (default: 0)
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public retrieveRoomBannedUsers(roomId: string, page?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).retrieveRoomBannedUsers(roomId, page, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Retrieve the list of moderators in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} anchorId The streamer\&#39;s numeric user ID
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public retrieveRoomModerators(anchorId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).retrieveRoomModerators(anchorId, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Retrieve the list of muted users in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} roomId The room ID of the livestream
     * @param {number} [page] Page number for pagination (default: 0)
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public retrieveRoomMutedUsers(roomId: string, page?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).retrieveRoomMutedUsers(roomId, page, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Toggle comments on/off in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} roomId The room ID of the livestream
     * @param {boolean} enabled Whether comments should be enabled (true) or disabled (false)
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public toggleRoomComments(roomId: string, enabled: boolean, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).toggleRoomComments(roomId, enabled, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Unkick a user from a livestream room (allow them back).  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} roomId The room ID of the livestream
     * @param {string} tiktokUserId The numeric user ID of the person to unkick
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public unbanRoomUser(roomId: string, tiktokUserId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).unbanRoomUser(roomId, tiktokUserId, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Unmute a user in a livestream room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} roomId The room ID of the livestream
     * @param {string} userId The user ID to unmute
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEModerationApi
     */
    public unmuteRoomUser(roomId: string, userId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEModerationApiFp(this.configuration).unmuteRoomUser(roomId, userId, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TikTokLIVEPremiumApi - axios parameter creator
 * @export
 */
export const TikTokLIVEPremiumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires Premium Routes Addon - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {RetrieveBulkLiveCheckRequest} retrieveBulkLiveCheckRequest The body of the request containing user numeric IDs.
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBulkLiveCheck: async (retrieveBulkLiveCheckRequest: RetrieveBulkLiveCheckRequest, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveBulkLiveCheckRequest' is not null or undefined
            assertParamExists('retrieveBulkLiveCheck', 'retrieveBulkLiveCheckRequest', retrieveBulkLiveCheckRequest)
            const localVarPath = `/webcast/bulk_live_check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveBulkLiveCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Retrieve detailed analytics for a specific past livestream.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream to get analytics for
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLiveAnalyticsVideoDetail: async (roomId: string, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('retrieveLiveAnalyticsVideoDetail', 'roomId', roomId)
            const localVarPath = `/webcast/live_analytics/video_detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of past livestreams with analytics for the authenticated user.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {number} [count] Number of videos to retrieve (default: 10)
         * @param {number} [offset] Pagination offset (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLiveAnalyticsVideoList: async (count?: number, offset?: number, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webcast/live_analytics/video_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Business Plan - Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo: async (uniqueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomInfo', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastFeed: async (region: OxyLabsProxyRegion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('retrieveWebcastFeed', 'region', region)
            const localVarPath = `/webcast/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Retrieve TikTok LIVE earnings for a specific user.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
         * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastUserEarnings: async (uniqueId: string, period?: WebcastUserEarningsOutputPeriod, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveWebcastUserEarnings', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/user_earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }


    
            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires Premium Routes Addon - Send a chat to a TikTok LIVE room.  Either `targetRoomId` or `targetUniqueId` must be provided to identify the room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {SendRoomChatRequest} sendRoomChatRequest The payload configuration for sending a chat
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat: async (sendRoomChatRequest: SendRoomChatRequest, xOauthToken?: string, xCookieHeader?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendRoomChatRequest' is not null or undefined
            assertParamExists('sendRoomChat', 'sendRoomChatRequest', sendRoomChatRequest)
            const localVarPath = `/webcast/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xOauthToken != null) {
                localVarHeaderParameter['x-oauth-token'] = String(xOauthToken);
            }
            if (xCookieHeader != null) {
                localVarHeaderParameter['x-cookie-header'] = String(xCookieHeader);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendRoomChatRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokLIVEPremiumApi - functional programming interface
 * @export
 */
export const TikTokLIVEPremiumApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokLIVEPremiumApiAxiosParamCreator(configuration)
    return {
        /**
         * Requires Premium Routes Addon - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {RetrieveBulkLiveCheckRequest} retrieveBulkLiveCheckRequest The body of the request containing user numeric IDs.
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBulkLiveCheck(retrieveBulkLiveCheckRequest: RetrieveBulkLiveCheckRequest, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveBulkLiveCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBulkLiveCheck(retrieveBulkLiveCheckRequest, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEPremiumApi.retrieveBulkLiveCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Retrieve detailed analytics for a specific past livestream.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream to get analytics for
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveLiveAnalyticsVideoDetail(roomId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveAnalyticsVideoDetailAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveLiveAnalyticsVideoDetail(roomId, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEPremiumApi.retrieveLiveAnalyticsVideoDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of past livestreams with analytics for the authenticated user.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {number} [count] Number of videos to retrieve (default: 10)
         * @param {number} [offset] Pagination offset (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveLiveAnalyticsVideoList(count?: number, offset?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveAnalyticsVideoListAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveLiveAnalyticsVideoList(count, offset, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEPremiumApi.retrieveLiveAnalyticsVideoList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Business Plan - Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomInfoRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomInfo(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEPremiumApi.retrieveRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveWebcastFeed(region: OxyLabsProxyRegion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastFeedRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveWebcastFeed(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEPremiumApi.retrieveWebcastFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Retrieve TikTok LIVE earnings for a specific user.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
         * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveWebcastUserEarnings(uniqueId: string, period?: WebcastUserEarningsOutputPeriod, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastUserEarningsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveWebcastUserEarnings(uniqueId, period, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEPremiumApi.retrieveWebcastUserEarnings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires Premium Routes Addon - Send a chat to a TikTok LIVE room.  Either `targetRoomId` or `targetUniqueId` must be provided to identify the room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {SendRoomChatRequest} sendRoomChatRequest The payload configuration for sending a chat
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRoomChat(sendRoomChatRequest: SendRoomChatRequest, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomChatRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRoomChat(sendRoomChatRequest, xOauthToken, xCookieHeader, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEPremiumApi.sendRoomChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokLIVEPremiumApi - factory interface
 * @export
 */
export const TikTokLIVEPremiumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokLIVEPremiumApiFp(configuration)
    return {
        /**
         * Requires Premium Routes Addon - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {RetrieveBulkLiveCheckRequest} retrieveBulkLiveCheckRequest The body of the request containing user numeric IDs.
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBulkLiveCheck(retrieveBulkLiveCheckRequest: RetrieveBulkLiveCheckRequest, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveBulkLiveCheckResponse> {
            return localVarFp.retrieveBulkLiveCheck(retrieveBulkLiveCheckRequest, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Retrieve detailed analytics for a specific past livestream.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} roomId The room ID of the livestream to get analytics for
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLiveAnalyticsVideoDetail(roomId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<LiveAnalyticsVideoDetailAPIResponse> {
            return localVarFp.retrieveLiveAnalyticsVideoDetail(roomId, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Retrieve the list of past livestreams with analytics for the authenticated user.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {number} [count] Number of videos to retrieve (default: 10)
         * @param {number} [offset] Pagination offset (default: 0)
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLiveAnalyticsVideoList(count?: number, offset?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<LiveAnalyticsVideoListAPIResponse> {
            return localVarFp.retrieveLiveAnalyticsVideoList(count, offset, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Business Plan - Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomInfoRouteResponse> {
            return localVarFp.retrieveRoomInfo(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
         * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastFeed(region: OxyLabsProxyRegion, options?: RawAxiosRequestConfig): AxiosPromise<WebcastFeedRouteResponse> {
            return localVarFp.retrieveWebcastFeed(region, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Retrieve TikTok LIVE earnings for a specific user.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
         * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
         * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebcastUserEarnings(uniqueId: string, period?: WebcastUserEarningsOutputPeriod, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastUserEarningsResponse> {
            return localVarFp.retrieveWebcastUserEarnings(uniqueId, period, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires Premium Routes Addon - Send a chat to a TikTok LIVE room.  Either `targetRoomId` or `targetUniqueId` must be provided to identify the room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
         * @param {SendRoomChatRequest} sendRoomChatRequest The payload configuration for sending a chat
         * @param {string} [xOauthToken] OAuth access token for session resolution
         * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat(sendRoomChatRequest: SendRoomChatRequest, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomChatRouteResponse> {
            return localVarFp.sendRoomChat(sendRoomChatRequest, xOauthToken, xCookieHeader, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokLIVEPremiumApi - object-oriented interface
 * @export
 * @class TikTokLIVEPremiumApi
 * @extends {BaseAPI}
 */
export class TikTokLIVEPremiumApi extends BaseAPI {
    /**
     * Requires Premium Routes Addon - A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {RetrieveBulkLiveCheckRequest} retrieveBulkLiveCheckRequest The body of the request containing user numeric IDs.
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEPremiumApi
     */
    public retrieveBulkLiveCheck(retrieveBulkLiveCheckRequest: RetrieveBulkLiveCheckRequest, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEPremiumApiFp(this.configuration).retrieveBulkLiveCheck(retrieveBulkLiveCheckRequest, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Retrieve detailed analytics for a specific past livestream.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} roomId The room ID of the livestream to get analytics for
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEPremiumApi
     */
    public retrieveLiveAnalyticsVideoDetail(roomId: string, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEPremiumApiFp(this.configuration).retrieveLiveAnalyticsVideoDetail(roomId, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Retrieve the list of past livestreams with analytics for the authenticated user.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {number} [count] Number of videos to retrieve (default: 10)
     * @param {number} [offset] Pagination offset (default: 0)
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEPremiumApi
     */
    public retrieveLiveAnalyticsVideoList(count?: number, offset?: number, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEPremiumApiFp(this.configuration).retrieveLiveAnalyticsVideoList(count, offset, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Business Plan - Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEPremiumApi
     */
    public retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEPremiumApiFp(this.configuration).retrieveRoomInfo(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Fetch the TikTok LIVE webcast feed for a specific region. Gets a random sampling of creators for a region.
     * @param {OxyLabsProxyRegion} region The region (country) with which to fetch a feed from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEPremiumApi
     */
    public retrieveWebcastFeed(region: OxyLabsProxyRegion, options?: RawAxiosRequestConfig) {
        return TikTokLIVEPremiumApiFp(this.configuration).retrieveWebcastFeed(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Retrieve TikTok LIVE earnings for a specific user.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {string} uniqueId The unique ID (username) of the user to fetch earnings for.
     * @param {WebcastUserEarningsOutputPeriod} [period] Earnings period
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {string} [sessionId] Use x-oauth-token or x-cookie-header instead
     * @param {string} [ttTargetIdc] Use x-oauth-token or x-cookie-header instead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEPremiumApi
     */
    public retrieveWebcastUserEarnings(uniqueId: string, period?: WebcastUserEarningsOutputPeriod, xOauthToken?: string, xCookieHeader?: string, sessionId?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEPremiumApiFp(this.configuration).retrieveWebcastUserEarnings(uniqueId, period, xOauthToken, xCookieHeader, sessionId, ttTargetIdc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires Premium Routes Addon - Send a chat to a TikTok LIVE room.  Either `targetRoomId` or `targetUniqueId` must be provided to identify the room.  **Authentication:** Provide exactly one of the following headers: - `x-oauth-token`: An OAuth access token. The sessionId and ttTargetIdc are resolved from the stored OAuth session. [Read More](https://www.eulerstream.com/docs/oauth) - `x-cookie-header`: A cookie header string containing `sessionid` and `tt-target-idc` cookies from TikTok.
     * @param {SendRoomChatRequest} sendRoomChatRequest The payload configuration for sending a chat
     * @param {string} [xOauthToken] OAuth access token for session resolution
     * @param {string} [xCookieHeader] Cookie header containing sessionid and tt-target-idc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEPremiumApi
     */
    public sendRoomChat(sendRoomChatRequest: SendRoomChatRequest, xOauthToken?: string, xCookieHeader?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEPremiumApiFp(this.configuration).sendRoomChat(sendRoomChatRequest, xOauthToken, xCookieHeader, options).then((request) => request(this.axios, this.basePath));
    }
}



